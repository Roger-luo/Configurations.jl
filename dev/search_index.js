var documenterSearchIndex = {"docs":
[{"location":"type_alias/#Option-Type-Alias","page":"Option Type Alias","title":"Option Type Alias","text":"","category":"section"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"Option type alias is useful when you don't want to type complicated Julia type expression, or your upstream schema doesn't use an explicit field to indicate the type of the sub-field.","category":"page"},{"location":"type_alias/#Use-an-Alias-for-the-Reflect-Type-Field","page":"Option Type Alias","title":"Use an Alias for the Reflect Type Field","text":"","category":"section"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"Sometimes, it can be tedious to have a long Julia expression (which may contain the module path) in the string for a Reflect type, e.g","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"using Configurations\n@option struct ALongOptionNameA\n    type::Reflect\n    x::Int = 1\nend\n\n@option struct ALongOptionNameB\n    type::Reflect\n    x::Int = 1\n    y::Int = 2\nend\n\n@option struct Composite\n    xxx::Union{ALongOptionNameA, ALongOptionNameB}\nend","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"d = to_dict(Composite(ALongOptionNameA()))\nd[\"xxx\"]","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"They can be relatively hard for human to edit in a markup language, or just hard to memorize as part of a schema specification. We can declare an alias name for such types to make things cleaner.","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"using Configurations\n@option \"case_a\" struct ALongOptionNameA\n    type::Reflect\n    x::Int = 1\nend\n\n@option \"case_b\" struct ALongOptionNameB\n    type::Reflect\n    x::Int = 1\n    y::Int = 2\nend\n\n@option struct Composite\n    xxx::Union{ALongOptionNameA, ALongOptionNameB}\nend","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"d = to_dict(Composite(ALongOptionNameA()))\nd[\"xxx\"]","category":"page"},{"location":"type_alias/#Multiple-Possible-Choices-of-Option-Types-without-Explicit-Type-Field","page":"Option Type Alias","title":"Multiple Possible Choices of Option Types without Explicit Type Field","text":"","category":"section"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"When there are multiple possible choices for an option-typed field, e.g","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"@option struct Options\n    options::Union{OptionA, OptionB}\nend","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"where OptionA and OptionB are also option types, one can specific which option type is it by using an alias when defining OptionA and OptionB","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"@option \"A\" struct OptionA\n    name::String\nend\n\n@option \"B\" struct OptionB\n    age::Int\nend","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"but they do not contain a field of type Reflect, then you can create an Options from the following Julia Dict","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"Dict{String, Any}(\n    \"options\" => Dict{String, Any}(\n        \"A\" => Dict{String, Any}(\n            \"name\"=>\"Roger\",\n        )\n    )\n)","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"or by using the following TOML file,","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"[options.A]\nname=\"Roger\"","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"the @option <alias> <struct def> syntax is only applicable to concrete types. for parametric types, one will need to manually define the string alias for the corresponding specialization.","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"You can declare these specialization using the @type_alias macro","category":"page"},{"location":"type_alias/","page":"Option Type Alias","title":"Option Type Alias","text":"@type_alias","category":"page"},{"location":"type_alias/#Configurations.@type_alias","page":"Option Type Alias","title":"Configurations.@type_alias","text":"@type_alias <type> <name::String>\n\nDefine a type alias for option type type. The corresponding type must be a concrete type in order to map this Julia type to a human readable markup language (e.g TOML, YAML, etc.).\n\n\n\n\n\n","category":"macro"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"CurrentModule = Configurations","category":"page"},{"location":"meta/#Meta-Programming","page":"Meta Programming","title":"Meta Programming","text":"","category":"section"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"For most use cases, the default API @option is sufficient, however, there are some specific cases requires one to use Configurations's advanced API on meta programming.","category":"page"},{"location":"meta/#Custom-Option-Macro","page":"Meta Programming","title":"Custom Option Macro","text":"","category":"section"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"In some cases, you may not want all the features we defined by default in Configurations.","category":"page"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"In this case, you can construct your own macro using the code generation passes defined in Configurations. The code generation passes API starts with codegen_. You combine them as a codegen pipeline.","category":"page"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"Configurations uses an intermediate representation defined by Expronicon to represent user defined option types, which is the JLKwStruct struct.","category":"page"},{"location":"meta/#Builtin-Code-Generators","page":"Meta Programming","title":"Builtin Code Generators","text":"","category":"section"},{"location":"meta/","page":"Meta Programming","title":"Meta Programming","text":"Modules = [Configurations]\nOrder   = [:function]\nPages   = [\"codegen.jl\"]","category":"page"},{"location":"meta/#Configurations.add_field_defaults!-Tuple{Module, ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.add_field_defaults!","text":"add_field_defaults!(m::Module, def::JLKwStruct)\n\nAdd default value for Maybe and Reflect type.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_convert-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_convert","text":"codegen_convert(x::JLKwStruct)\n\nGenerate Base.convert from AbstractDict{String} to the given option type.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_create-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_create","text":"codegen_create(def::JLKwStruct)\n\nGenerate Configurations.create overload.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_field_default-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_field_default","text":"codegen_field_default(def::JLKwStruct)\n\nGenerate field_default overload to support the default value reflection.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_from_dict_specialize-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_from_dict_specialize","text":"codegen_from_dict_specialize(def::JLKwStruct)\n\nGenerate the specialized from_dict for the given definition.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_is_option-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_is_option","text":"codegen_is_option(x::JLKwStruct)\n\nGenerate the is_option method.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_isequal-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_isequal","text":"codegen_isequal(x::JLKwStruct)\n\nGenerate Base.:(==) to overload comparison operator to compare_options for given option type.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_option_type-Tuple{Module, ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_option_type","text":"codegen_option_type(mod::Module, def::JLKwStruct)\n\nGenerate the Configurations option type definition from a given JLKwStruct created by Expronicon.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.codegen_type_alias-Tuple{ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.codegen_type_alias","text":"codegen_type_alias(def::JLKwStruct)\n\nGenerate type alias method type_alias.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.has_duplicated_reflect_type-Tuple{Module, ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.has_duplicated_reflect_type","text":"has_duplicated_reflect_type(m::Module, def::JLKwStruct)\n\nCheck if the definition has duplicated reflect type.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.is_maybe_type_expr-Tuple{Module, Any}","page":"Meta Programming","title":"Configurations.is_maybe_type_expr","text":"is_maybe_type_expr(m::Module, @nospecialize(ex))\n\nCheck if the expression ex evaluates to a Maybe{T}.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.is_reflect_type_expr-Tuple{Module, Any}","page":"Meta Programming","title":"Configurations.is_reflect_type_expr","text":"is_reflect_type_expr(m::Module, @nospecialize(ex))\n\nCheck if the expression ex evaluates to a Reflect.\n\n\n\n\n\n","category":"method"},{"location":"meta/#Configurations.validate_option_def-Tuple{Module, ExproniconLite.JLKwStruct}","page":"Meta Programming","title":"Configurations.validate_option_def","text":"validate_option_def(def::JLKwStruct)\n\nValidate the option definition.\n\n\n\n\n\n","category":"method"},{"location":"ref/","page":"References","title":"References","text":"CurrentModule = Configurations","category":"page"},{"location":"ref/#Reference","page":"References","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [Configurations]","category":"page"},{"location":"ref/#Configurations.JSONStyle","page":"References","title":"Configurations.JSONStyle","text":"JSONStyle::ToDictOption\n\nPredefined option for JSON compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.Maybe","page":"References","title":"Configurations.Maybe","text":"maybe of type T or nothing\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.TOMLStyle","page":"References","title":"Configurations.TOMLStyle","text":"TOMLStyle::ToDictOption\n\nPredefined option for TOML compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.YAMLStyle","page":"References","title":"Configurations.YAMLStyle","text":"YAMLStyle::ToDictOption\n\nPredefined option for YAML compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.ConvertNotFound","page":"References","title":"Configurations.ConvertNotFound","text":"ConvertNotFound\n\nConversion is not defined via convert_to_option. One should let the conversion fallback to Base.convert when see this.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.DuplicatedFieldError","page":"References","title":"Configurations.DuplicatedFieldError","text":"DuplicatedFieldError(name, type)\n\nA field with name of given option type is duplicated in the subfields option type. Thus one cannot use the field keyword convention when seeing this error.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.FieldTypeConversionError","page":"References","title":"Configurations.FieldTypeConversionError","text":"FieldTypeConversionError(type, fieldname, fieldtype, optiontype)\n\nA conversion from type to fieldtype belonging to fieldname in an optiontype failed.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.OptionField","page":"References","title":"Configurations.OptionField","text":"OptionField{name}\nOptionField(name::Symbol)\n\nTrait type that denotes a field of an option type. Mainly used for dispatch purpose. name should be a Symbol.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.PartialDefault","page":"References","title":"Configurations.PartialDefault","text":"PartialDefault{F}\n\nType for non-constant default value, it depends on the value of another field that has default value.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.alias_map-Tuple{Vector{Any}}","page":"References","title":"Configurations.alias_map","text":"alias_map(types::Vector{Any})\n\nCreate a Dict mapping type alias to a type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.compare_options-Tuple{Any, Any, Vararg{Any}}","page":"References","title":"Configurations.compare_options","text":"compare_options(a, b, xs...)::Bool\n\nCompare option types check if they are the same.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T","page":"References","title":"Configurations.convert_to_option","text":"convert_to_option(::Type{OptionType}, ::Type{ValueType}, x) where {OptionType, ValueType}\n\nConvert x to type ValueType for option type OptionType. This is similar to Base.convert, but will not error if the conversion is not overloaded, and will return a ConvertNotFound object, but one can use this to avoid type piracy and define contextual conversion based on option types.\n\ncompat: Configurations 0.17\nThis interface is deprecated in favor of from_dict from 0.17.\n\nExample\n\nOne may have different string syntax for a Symbol, e.g\n\n@option struct StringIsSymbol\n    name::Symbol\nend\n\n@option struct SymbolNeedsColon\n    name::Symbol\nend\n\nConfigurations.convert_to_option(::Type{StringIsSymbol}, ::Type{Symbol}, x::String) = Symbol(x)\n\nfunction Configurations.convert_to_option(::Type{SymbolNeedsColon}, ::Type{Symbol}, x::String)\n    if startswith(x, ':')\n        Symbol(x[2:end])\n    else\n        error(\"expect a Symbol, got String\")\n    end\nend\n\nthen if we run it, we will have different behaviour by context.\n\njulia> from_dict(StringIsSymbol, d)\nStringIsSymbol(:ccc)\n\njulia> from_dict(SymbolNeedsColon, d)\nERROR: expect a Symbol, got String\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.create-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.create","text":"create(::Type{T}; kwargs...) where T\n\nCreate an instance of option type T from kwargs. Similar to the default keyword argument constructor, but one can use this to create custom keyword argument constructor with extra custom keywords.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_default-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"References","title":"Configurations.field_default","text":"field_default(::Type{T}, name::Symbol)\n\nReturn the default value of field name of an option type T.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_defaults-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.field_defaults","text":"field_defaults(::Type)\n\nReturn default values of given option types.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.field_keywords","text":"field_keywords(::Type{T}) where T\n\nReturn all the option type field names given T, error if there are duplicated sub-fields.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict-Union{Tuple{OptionType}, Tuple{Type{OptionType}, AbstractDict{String}}} where OptionType","page":"References","title":"Configurations.from_dict","text":"from_dict(::Type{T}, d::AbstractDict{String}; kw...) where T\n\nConvert dictionary d to an option type T, the value of valid fields of T in this dictionary d can be override by keyword arguments.\n\ncompat: Configurations 0.17\nconvert_to_option interface is deprecated for conversion, please overload the 3-arg or 4-arg from_dict instead. See also Type Conversion section.\n\nExample\n\njulia> @option struct OptionA\n           name::String = \"Sam\"\n           age::Int = 25\n       end\n\njulia> d = Dict{String, Any}(\n           \"name\" => \"Roger\",\n           \"age\" => 10,\n       );\n\njulia> from_dict(OptionA, d; age=25)\nOptionA(;\n    name = \"Roger\",\n    age = 25,\n)\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict-Union{Tuple{T}, Tuple{f_name}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField{f_name}, Type{T}, Any}} where {OptionType, f_name, T}","page":"References","title":"Configurations.from_dict","text":"from_dict(::Type{OptionType}, ::OptionField{f_name}, ::Type{T}, x) where {OptionType, f_name, T}\n\nFor option type OptionType, convert the object x to the field type T and assign it to the field f_name. Raise FieldTypeConversionErrors errors if Base.convert raises exception\n\nERROR: MethodError: Cannot `convert` an object of type ...\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict_generated-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Symbol}} where OptionType","page":"References","title":"Configurations.from_dict_generated","text":"from_dict_generated(::Type{OptionType}, value::Symbol) where {OptionType}\n\nGenerate a specialized Julia expression to convert an AbstractDict{String} to our OptionType.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict_specialize-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Any}} where OptionType","page":"References","title":"Configurations.from_dict_specialize","text":"from_dict_specialize(::Type{OptionType}, x) where {OptionType}\n\nA specialized from_dict method for option type OptionType. This is usually generated by @option, but one may also specialized this manually to acheive maximal performance.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_field_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_field_kwargs","text":"from_field_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the field keyword convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs!-Union{Tuple{T}, Tuple{AbstractDict{String}, Type{T}}, Tuple{AbstractDict{String}, Type{T}, Union{Nothing, Symbol}}} where T","page":"References","title":"Configurations.from_kwargs!","text":"from_kwargs!(d::AbstractDict{String}, ::Type{T}, prefix::Maybe{Symbol} = nothing; kw...) where T\n\nInternal method for inserting keyword arguments to given dictionary object d. It will overwrite existing keys in d if it is specified by keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_kwargs","text":"from_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"References","title":"Configurations.from_kwargs","text":"from_kwargs(convention!, ::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using convention!. See also from_dict.\n\nConvention\n\nfrom_underscore_kwargs!: use _ to disambiguate subfields of the same name, this is the default behaviour.\nfrom_field_kwargs!: do not disambiguate subfields, errors if there are disambiguity\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_toml-Union{Tuple{T}, Tuple{Type{T}, String}} where T","page":"References","title":"Configurations.from_toml","text":"from_toml(::Type{T}, filename::String; kw...) where T\n\nConvert a given TOML file filename to an option type T. Valid fields can be override by keyword arguments. See also from_dict.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_toml_if_exists-Union{Tuple{T}, Tuple{Type{T}, String}} where T","page":"References","title":"Configurations.from_toml_if_exists","text":"from_toml_if_exists(::Type{T}, filename::String; kw...) where T\n\nSimilar to from_toml but will create the option instance via from_kwargs(T;kw...) instead of error if the file does not exist.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_underscore_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_underscore_kwargs","text":"from_underscore_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.has_same_reflect_field-Tuple{Vector{Any}}","page":"References","title":"Configurations.has_same_reflect_field","text":"has_same_reflect_field(types::Vector{Any})\n\nCheck if all types has the same reflect field name.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.ignore_extra-Union{Tuple{Type{OptionType}}, Tuple{OptionType}} where OptionType","page":"References","title":"Configurations.ignore_extra","text":"ignore_extra(option_type) -> Bool\n\nReturn true if the option type ignores extra fields when read from a dict-like object.\n\nnote: Note\nNormally, we require the dict-like object to have exactly the same number of fields with the option type. However, it could be useful to have ignore extra fields when wrapping network work services to ignore some irrelavent optional fields.\n\nnote: Note\nUnlike pydantic, we do not allow dynamically adding fields to a given type. One should manually define fields you would like to include in a struct type and let it to have type Dict{String, Any}.\n\nExample\n\njulia> Configurations.ignore_extra(::Type{MyOption}) = true\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.is_option-Tuple{Any}","page":"References","title":"Configurations.is_option","text":"is_option(x)\n\nCheck if x is an option type or not.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.is_option_maybe-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.is_option_maybe","text":"is_option_maybe(::Type{T}) where T\n\nT is an option struct or if T is an union, one of the types is an option struct.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Tuple{Any, Configurations.ToDictOption}","page":"References","title":"Configurations.to_dict","text":"to_dict(x, option::ToDictOption) -> OrderedDict\n\nConvert an object x to an OrderedDict with ToDictOption specified.\n\nExample\n\nto_dict(x, TOMLStyle) # TOML compatible\nto_dict(x, YAMLStyle) # YAML compatible\nto_dict(x, JSONStyle) # JSON compatible\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Tuple{Any}","page":"References","title":"Configurations.to_dict","text":"to_dict(x; include_defaults=true, exclude_nothing=false) -> OrderedDict\n\nConvert an object x to an OrderedDict.\n\nKwargs\n\ninclude_defaults: include the default value, default is true.\nexclude_nothing: exclude fields that have value nothing,   this supersedes include_defaults when they are both true.\n\nFormat Compatibilty\n\nWhen mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as TOMLStyle, YAMLStyle, JSONStyle.\n\ntips: Tips\nto_dict does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use include_defaults, however,  this can be overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Union{Tuple{T}, Tuple{Type{T}, Any, Configurations.ToDictOption}} where T","page":"References","title":"Configurations.to_dict","text":"to_dict(::Type{T}, x, option::ToDictOption) where T\n\nConvert x when x is inside an option type T. option is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of to_dict(x; kw...).\n\nto_dict(::Type{T}, x) where T\n\nOne can also use the 2-arg version when x is not or does not contain an option type for convenience.\n\nExample\n\nThe following is a builtin overload to handle list of options.\n\nfunction Configurations.to_dict(::Type{T}, x::Vector, option::ToDictOption) where T\n    if is_option(eltype(x))\n        return map(p->to_dict(T, p, include_defaults), x)\n    else\n        return x\n    end\nend\n\nThe following overloads the 2-arg to_dict to convert all VersionNumber to a String for all kinds of option types.\n\nConfigurations.to_dict(::Type, x::VersionNumber) = string(x)\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any, IO, Any}","page":"References","title":"Configurations.to_toml","text":"to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to IO. See to_dict for other valid keyword options. See also TOML.print in the stdlib for the explaination of sorted, by and f.\n\nExclude nothing\n\nIn TOML specification, there is no null type. One should exclude the field if it is not specified (of value nothing in Julia). In to_toml the option exclude_nothing is always true.\n\nIn most cases, nothing is used with another type to denote optional or not specified field, thus one should always put a default value nothing to the option struct, e.g\n\nOne should define\n\n@option struct OptionX\n    a::Union{Nothing, Int} = nothing\n    b::Maybe{Int} = nothing\nend\n\nHere Maybe{T} is a convenient alias of Union{Nothing, T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any, String, Any}","page":"References","title":"Configurations.to_toml","text":"to_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to filename. See also TOML.print.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any}","page":"References","title":"Configurations.to_toml","text":"to_toml(x; sorted=false, by=identity, kw...)\n\nConvert an instance x of option type to TOML and write it to String. See also TOML.print. \n\nto_toml does not export fields that are of the same values as the defaults. This can be  overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.type_alias-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.type_alias","text":"type_alias(::Type{OptionType}) -> String\n\nReturn the alias name of given OptionType.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.underscore_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.underscore_keywords","text":"underscore_keywords(::Type{T}) where T\n\nReturn keywords given T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.@option-Tuple{Any}","page":"References","title":"Configurations.@option","text":"@option [alias::String] <struct def>\n\nDefine an option struct type. This will auto-generate methods that parse a given Dict{String} object (the keys must be of type String) into an instance of the struct type you defined. One can use alias string to distinguish multiple possible option type for the same field.\n\nSpecial Types\n\nMaybe{T}: this type is equivalent to Union{Nothing, T} and   is treated specially in @option, it will always have a default   value of nothing if not specified.\nReflect: this type is treated specially to allow one to use a field   to store the corresponding type information.\n\ncompat: Configurations 0.16\nfrom v0.16.0 Configurations stops overloading the Base.show method for you, if you need pretty printing of your option types, consider overloading the Base.show(io::IO, mime::MIME, x) method to pprint_struct(io, mime, x) provided by GarishPrint\n\ncompat: Configurations 0.12\nfrom v0.12.0 the field alias feature is removed due to the syntax conflict with field docstring. Please refer to #17.\n\nExample\n\nOne can define option type via @option macro with or without an alias.\n\njulia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)\n\nwhen there are multiple possible option type for one field, one can use the alias to distinguish them\n\njulia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\n\n\n\n\n","category":"macro"},{"location":"ref/#Configurations.@type_alias-Tuple{Any, String}","page":"References","title":"Configurations.@type_alias","text":"@type_alias <type> <name::String>\n\nDefine a type alias for option type type. The corresponding type must be a concrete type in order to map this Julia type to a human readable markup language (e.g TOML, YAML, etc.).\n\n\n\n\n\n","category":"macro"},{"location":"#Configurations","page":"Home","title":"Configurations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Configurations & Options made easy.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nConfigurations is a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package. To install Configurations,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a> and press <kbd>]</kbd> key in the REPL to use the package mode, then type the following command\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Configurations","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a macro @option to let you define structs to represent options/configurations, and serialize between different option/configuration file format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@option","category":"page"},{"location":"#Configurations.@option","page":"Home","title":"Configurations.@option","text":"@option [alias::String] <struct def>\n\nDefine an option struct type. This will auto-generate methods that parse a given Dict{String} object (the keys must be of type String) into an instance of the struct type you defined. One can use alias string to distinguish multiple possible option type for the same field.\n\nSpecial Types\n\nMaybe{T}: this type is equivalent to Union{Nothing, T} and   is treated specially in @option, it will always have a default   value of nothing if not specified.\nReflect: this type is treated specially to allow one to use a field   to store the corresponding type information.\n\ncompat: Configurations 0.16\nfrom v0.16.0 Configurations stops overloading the Base.show method for you, if you need pretty printing of your option types, consider overloading the Base.show(io::IO, mime::MIME, x) method to pprint_struct(io, mime, x) provided by GarishPrint\n\ncompat: Configurations 0.12\nfrom v0.12.0 the field alias feature is removed due to the syntax conflict with field docstring. Please refer to #17.\n\nExample\n\nOne can define option type via @option macro with or without an alias.\n\njulia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)\n\nwhen there are multiple possible option type for one field, one can use the alias to distinguish them\n\njulia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\n\n\n\n\n","category":"macro"},{"location":"#Frequently-Asked-Questions","page":"Home","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When should I use this package?","category":"page"},{"location":"","page":"Home","title":"Home","text":"When you have a lot settings/preferences/keyword arguments for a package or a function, or you need to validate a JSON schema, a REST API for your web server. A similar package in Python is pydantic in Python, but this package only provides the basic feature, a pydantic compatible package will be developed in the future in KungIChi.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A common type of code is instead of writing many keyword arguments, like foo(;kw_a=1, kw_b=2, kw_c, ...), wrap them in an option type","category":"page"},{"location":"","page":"Home","title":"Home","text":"@option struct FooOptions\n    kw_a::Int = 1\n    kw_b::Int = 2\n    # ...\nend\n\nfoo(x, y;kw...) = foo(x, y, FooOptions(;kw...))\nfoo(x, y, options::FooOptions) = #= actual implementation =#","category":"page"},{"location":"","page":"Home","title":"Home","text":"this will make your keyword argument easy to read and serialize with readable markup language like TOML.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why Configurations only supports TOML?","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is not true, Configurations supports converting a dictionary type (subtype of AbstractDict{String}) to option types defined by @option. The reason why TOML is supported by default is because Julia is shipped with a TOML parser already, so we can support TOML without adding extra dependency. And depending on other format parsers such as YAML, JSON etc. will cause an extra loading latency that is not necessary for most of the users who is fine with just TOML. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, Configurations aims to be lightweight because it is used by latency sensitive packages like Comonicon. We will put other features into KungIChi in the future (it is still work-in-progress).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why do you need an @option macro?","category":"page"},{"location":"","page":"Home","title":"Home","text":"the @option macro provides the functionality of reflection in compile time, e.g we support type alias and default value reflection. These feature is not implementable without macros.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why not just use a supertype but a macro?","category":"page"},{"location":"","page":"Home","title":"Home","text":"besides the reason in the previous question, for a specific project, we can write a supertype and implement a set of generic interface, which is fine. But as a package, we need to make things composable and generic, thus, we do not want to block users from defining their own supertype. In this package, we use traits instead of supertypes, this makes things composable, e.g you can use the option types defined in Pluto as part of your own option types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is the difference between this package and Preferences","category":"page"},{"location":"","page":"Home","title":"Home","text":"Preferences aims to provide a mechanism of reading package preferences that works with the package manager Pkg, but this package aims to provide a mechnism to read a setting/preference to Julia structs. Thus these two are completely orthogonal packages and they can work together.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is the difference between this package and StructTypes","category":"page"},{"location":"","page":"Home","title":"Home","text":"StructTypes is mainly used to provide a standard interface to parse dict-like data to a Julia struct via traits to make parsing faster, but this package aims to support the mapping between a dict-like data and a specific kind of Julia struct defined by @option which provides limited semantic that is not as general as a normal Julia struct (it is closer to Base.@kwdef semantic). And we have plans of supporting StructTypes traits by default once JuliaData/StructTypes#53 is figured out.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License","category":"page"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/#Create-an-option-type","page":"Quick Start","title":"Create an option type","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Create an option type with macro @option as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"@option struct YouOptionType <: YourAbstractType\n   a::Int = 1\n   b::Float64 # required field\nend","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"then you can use this as an option type, it can let you:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"convert an option type defined in Julia to a markup language, such as TOML, JSON\nread from plain AbstractDict{String}, TOML, JSON etc. and convert the data to the option type\ncompose several option types together","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You can easily create hierarchical struct types as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"and convert a dict to an option type via from_dict.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"when there are multiple possible option type for one field, one can use the alias to distinguish them","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\njulia> using Configurations\n\njulia> @option struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> @option struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\njulia> d = Dict(\n           \"opt\" => Dict(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       )\nDict{String, Any} with 2 entries:\n  \"opt\"   => Dict{String, Any}(\"int\"=>2, \"name\"=>\"Roger\")\n  \"float\" => 0.33\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n  opt = OptionA(;\n    name = \"Roger\",\n    int = 2,\n  ),\n  float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Or you can also create it from keyword arguments, e.g","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> from_kwargs(OptionB; opt_name=\"Roger\", opt_int=2, float=0.33)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for option types you can always convert AbstractDict to a given option type, or convert them back to dictionary via to_dict, e.g","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> Configurations.to_dict(option)\nOrderedDict{String, Any} with 2 entries:\n  \"opt\"   => OrderedDict{String, Any}(\"name\"=>\"Roger\", \"int\"=>2)\n  \"float\" => 0.33","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for serialization, you can use the builtin TOML support","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> to_toml(option)\n\"float = 0.33\\n\\n[opt]\\nname = \\\"Roger\\\"\\nint = 2\\n\"","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Or serialize it to other format from OrderedDict.","category":"page"},{"location":"quick-start/#The-Reflect-Type","page":"Quick Start","title":"The Reflect Type","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can use Reflect type to denote a field contains the type information of the struct.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Reflect","category":"page"},{"location":"quick-start/#Configurations.Reflect","page":"Quick Start","title":"Configurations.Reflect","text":"Reflect\n\nPlaceholder type for reflected type string.\n\nType Alias\n\nif the corresponding type has a type_alias defined, serialization and parsing will use the type_alias instead of the type name, this only works on concrete types since the alias cannot contain any type var information.\n\nExample\n\nthe following option struct\n\n@option struct MyOption\n    type::Reflect\n    name::String = \"Sam\"\nend\n\nwould be equivalent to\n\ntype = \"MyOption\"\nname = \"Sam\"\n\nthis is useful for defining list of different types etc.\n\n\n\n\n\n","category":"type"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This is useful when you have a few different option type for one field, e.g","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"@option struct Option\n   field::Union{OptionA, OptionB, OptionC}\nend","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"the type information of different type will be embeded in the corresponding string of the Reflect field.","category":"page"},{"location":"quick-start/#Create-pretty-printing-for-your-option-type","page":"Quick Start","title":"Create pretty printing for your option type","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can overload the Base.show method to create your own pretty printing. However, if you are fine with the printing style provided by GarishPrint, you can simply define the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"# using GarishPrint\nBase.show(io::IO, ::MIME\"text/plain\", x::MyOption) = GarishPrint.pprint_struct(io, x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This will enable pretty printing provided by GarishPrint when a rich text environment is available, and it will fallback to the default julia printing if \"text/plain\" MIME type is not available.","category":"page"},{"location":"quick-start/#Read-from-Keyword-Arguments","page":"Quick Start","title":"Read from Keyword Arguments","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Option types can be used to organize large number of keyword arguments, and one can also construct an option type from keyword arguments via from_kwargs","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations.from_kwargs","category":"page"},{"location":"quick-start/#Configurations.from_kwargs","page":"Quick Start","title":"Configurations.from_kwargs","text":"from_kwargs(convention!, ::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using convention!. See also from_dict.\n\nConvention\n\nfrom_underscore_kwargs!: use _ to disambiguate subfields of the same name, this is the default behaviour.\nfrom_field_kwargs!: do not disambiguate subfields, errors if there are disambiguity\n\n\n\n\n\nfrom_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"A real world example is the Pluto configuration.","category":"page"},{"location":"quick-start/#Read-from-TOML-files","page":"Quick Start","title":"Read from TOML files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations supports TOML file by default via the TOML standard library, you can directly read a TOML file to your option types via from_toml.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"from_toml","category":"page"},{"location":"quick-start/#Configurations.from_toml","page":"Quick Start","title":"Configurations.from_toml","text":"from_toml(::Type{T}, filename::String; kw...) where T\n\nConvert a given TOML file filename to an option type T. Valid fields can be override by keyword arguments. See also from_dict.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/#Read-from-YAML-files","page":"Quick Start","title":"Read from YAML files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You can use the JuliaData/YAML package to parse a YAML file to a Dict{String, Any},","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using YAML, Configurations\n\njulia> @option struct MyOption\n           a::Int\n           b::Float64\n       end\n\njulia> data = YAML.load_file(\"test.yml\"; dicttype=Dict{String, Any})\nDict{String, Any} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> from_dict(MyOption, data)\nMyOption(1, 2.0)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"but remember to tell the YAML parser that you would like the keys to be String since from_dict expects the dictionary to be AbstractDict{String}, this can be done via dicttype keyword as above example.","category":"page"},{"location":"quick-start/#Read-JSON-files","page":"Quick Start","title":"Read JSON files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can read JSON files as a dictionary via JuliaIO/JSON.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON\n\njulia> d = JSON.parse(\"{\\\"a\\\":1,\\\"b\\\":2.1}\")\nDict{String, Any} with 2 entries:\n  \"b\" => 2.1\n  \"a\" => 1\n\njulia> from_dict(MyOption, d)\nMyOption(1, 2.1)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"or for JSON3 you can use the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON3, Configurations\n\njulia> @option struct OptionA\n        x::String = \"hi\"\n        y::Vector{String} = String[]\n           end\n\njulia> d = JSON3.read(\"\"\"\n           {\"y\": [\"a\"]}\n           \"\"\", Dict{String, Any})\nDict{String, Any} with 1 entry:\n  \"y\" => Any[\"a\"]\n\njulia> from_dict(OptionA, d)\nOptionA(\"hi\", [\"a\"])","category":"page"},{"location":"quick-start/#Read-other-formats","page":"Quick Start","title":"Read other formats","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For other formats, as long as you can convert them to a subtype of AbstractDict{String}, you can always convert it to the option type you just defined via from_dict, however for the sake of simplicity Configurations will not ship such functionality with it.","category":"page"},{"location":"quick-start/#Write-to-TOML","page":"Quick Start","title":"Write to TOML","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To write the option struct to a TOML file, simply use the to_toml function","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> to_toml(option; include_defaults=false) # write to a String\n\njulia> to_toml(\"test.toml\", option; include_defaults=false) # write to a file","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You may also be interested in the docstring of to_toml","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"to_toml","category":"page"},{"location":"quick-start/#Configurations.to_toml","page":"Quick Start","title":"Configurations.to_toml","text":"to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to IO. See to_dict for other valid keyword options. See also TOML.print in the stdlib for the explaination of sorted, by and f.\n\nExclude nothing\n\nIn TOML specification, there is no null type. One should exclude the field if it is not specified (of value nothing in Julia). In to_toml the option exclude_nothing is always true.\n\nIn most cases, nothing is used with another type to denote optional or not specified field, thus one should always put a default value nothing to the option struct, e.g\n\nOne should define\n\n@option struct OptionX\n    a::Union{Nothing, Int} = nothing\n    b::Maybe{Int} = nothing\nend\n\nHere Maybe{T} is a convenient alias of Union{Nothing, T}.\n\n\n\n\n\nto_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to filename. See also TOML.print.\n\n\n\n\n\nto_toml(x; sorted=false, by=identity, kw...)\n\nConvert an instance x of option type to TOML and write it to String. See also TOML.print. \n\nto_toml does not export fields that are of the same values as the defaults. This can be  overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/#Write-to-YAML","page":"Quick Start","title":"Write to YAML","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To write the option struct to other formats, you need to convert it to a dictionary type first via to_dict","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"to_dict","category":"page"},{"location":"quick-start/#Configurations.to_dict","page":"Quick Start","title":"Configurations.to_dict","text":"to_dict(x; include_defaults=true, exclude_nothing=false) -> OrderedDict\n\nConvert an object x to an OrderedDict.\n\nKwargs\n\ninclude_defaults: include the default value, default is true.\nexclude_nothing: exclude fields that have value nothing,   this supersedes include_defaults when they are both true.\n\nFormat Compatibilty\n\nWhen mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as TOMLStyle, YAMLStyle, JSONStyle.\n\ntips: Tips\nto_dict does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use include_defaults, however,  this can be overridden by changing include_defaults to true.\n\n\n\n\n\nto_dict(x, option::ToDictOption) -> OrderedDict\n\nConvert an object x to an OrderedDict with ToDictOption specified.\n\nExample\n\nto_dict(x, TOMLStyle) # TOML compatible\nto_dict(x, YAMLStyle) # YAML compatible\nto_dict(x, JSONStyle) # JSON compatible\n\n\n\n\n\nto_dict(::Type{T}, x, option::ToDictOption) where T\n\nConvert x when x is inside an option type T. option is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of to_dict(x; kw...).\n\nto_dict(::Type{T}, x) where T\n\nOne can also use the 2-arg version when x is not or does not contain an option type for convenience.\n\nExample\n\nThe following is a builtin overload to handle list of options.\n\nfunction Configurations.to_dict(::Type{T}, x::Vector, option::ToDictOption) where T\n    if is_option(eltype(x))\n        return map(p->to_dict(T, p, include_defaults), x)\n    else\n        return x\n    end\nend\n\nThe following overloads the 2-arg to_dict to convert all VersionNumber to a String for all kinds of option types.\n\nConfigurations.to_dict(::Type, x::VersionNumber) = string(x)\n\n\n\n\n\n","category":"function"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Then you can use YAML package to write the dict to a YAML file","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using YAML, Configurations\n\njulia> d = to_dict(your_option, YAMLStyle)\n\njulia> YAML.write_file(\"myfile.yaml\", d)","category":"page"},{"location":"quick-start/#Write-to-JSON","page":"Quick Start","title":"Write to JSON","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"or for JSON, we recommend using JSON or JSON3 to write the file as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for JSON","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON, Configurations\n\njulia> d = to_dict(your_option, JSONStyle)\n\njulia> open(\"file.json\", \"w\") do f\n           JSON.print(f, d)\n       end","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for JSON3 you can use the following code snippet","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON3, Configurations\n\njulia> @option struct OptionA\n        x::String = \"hi\"\n        y::Vector{String} = String[]\n    end\n\njulia> d = to_dict(OptionA(y=[\"a\"]))\n\njulia> JSON3.write(d)\n\"{\\\"x\\\":\\\"hi\\\",\\\"y\\\":[\\\"a\\\"]}\"\n\njulia> JSON3.write(\"file.json\", d) # write to a file\n\"file.json\"","category":"page"},{"location":"quick-start/#Write-to-other-formats","page":"Quick Start","title":"Write to other formats","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For other formats, you can convert your option struct to an OrderedDict{String, Any} via to_dict then serialize the dictionary to your desired format.","category":"page"},{"location":"quick-start/#Work-with-StructTypes-and-JSON3","page":"Quick Start","title":"Work with StructTypes and JSON3","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can work with StructType with Configurations to make JSON.read(json_string, MyOptionType) work automatically by copying the following code and replace MyOptionType with your own option struct types.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using StructTypes\nusing Configurations\nStructTypes.StructType(::Type{<:MyOptionType}) = StructTypes.CustomStruct()\nStructTypes.lower(x::MyOptionType) = to_dict(x, JSONStyle)\nStructTypes.lowertype(::Type{<:MyOptionType}) = OrderedDict{String, Any}\nStructTypes.construct(::Type{T}, x) where {T <: MyOptionType} = from_dict(T, x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"then JSON.read(\"// a json string or IO\", MyOptionType) will just work.","category":"page"},{"location":"quick-start/#Type-Conversion","page":"Quick Start","title":"Type Conversion","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Since markup languages usually do not support arbitrary Julia types, thus, one may find the from_dict complain that cannot convert an object of type XXX to an object of type YYY. Usually this is because you haven't overload Base.convert from XXX to YYY for the custom struct type, usually this can be resolved via the following overload","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Base.convert(::Type{MyType}, x::String) = MyType(x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"where we assume you have written a constructor from String here.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"However, in some cases, you may want to do the conversion only for one OptionType without causing type piracy, for example, one may want to convert all the String to Symbol for MyOption, this can be done by overloading Configurations.from_dict","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations.from_dict(::Type{MyOption}, ::Type{Symbol}, s) = Symbol(s)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For more detailed type conversion mechanism, please read the Type Conversion section.","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"CurrentModule = Configurations","category":"page"},{"location":"convert/#type-conversion","page":"Type Conversion","title":"Type Conversion and Custom Parsing","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"If you find from_dict or from_toml doesn't not support a Julia type, such as Symbol, this is usually because the corresponding parser or format doesn't support this Julia type natively, in this case you will need to define your own type conversion for this option type by overloading Configurations.from_dict","category":"page"},{"location":"convert/#How-does-it-work?","page":"Type Conversion","title":"How does it work?","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"The type conversion for option types work as following:","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"if we find the target type does not match the value type, we will call Configurations.from_dict\nif Configurations.from_dict is not overloaded, it will try to call Base.convert\nif Base.convert doesn't work, a standard conversion failure error will be thrown by Base.convert.","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"Thus, if Base.convert is already overloaded, this will just work, or if the conversion rule is contextual based on the option type, one can also overload Configurations.from_dict, this also avoids potential type piracy.","category":"page"},{"location":"convert/#The-Overloading-Interface","page":"Type Conversion","title":"The Overloading Interface","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"from_dict provides two overloading interface","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"from_dict(::Type{OptionType}, ::OptionField, ::Type{T}, x) where {OptionType,T}\nfrom_dict(::Type{OptionType}, ::Type{T}, x) where {OptionType,T}","category":"page"},{"location":"convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField, Type{T}, Any}} where {OptionType, T}","page":"Type Conversion","title":"Configurations.from_dict","text":"from_dict(::Type{OptionType}, ::OptionField{f_name}, ::Type{T}, x) where {OptionType, f_name, T}\n\nFor option type OptionType, convert the object x to the field type T and assign it to the field f_name. Raise FieldTypeConversionErrors errors if Base.convert raises exception\n\nERROR: MethodError: Cannot `convert` an object of type ...\n\n\n\n\n\n","category":"method"},{"location":"convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, Type{T}, Any}} where {OptionType, T}","page":"Type Conversion","title":"Configurations.from_dict","text":"from_dict(::Type{OptionType}, ::Type{T}, x) where {OptionType, T}\n\nFor option type OptionType, convert the object x to type T. This is similar to Base.convert(::Type{T}, x) and will fallback to Base.convert if not defined.\n\n\n\n\n\n","category":"method"},{"location":"convert/#Example:-Contextual-Conversion","page":"Type Conversion","title":"Example: Contextual Conversion","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"using Configurations\n\n@option struct MyOption\n    a::Int\n    b::Symbol\nend","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"directly calling from_dict will have the following error","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"@option struct MyOption\n    a::Int\n    b::Symbol\nend\n\nd = Dict{String, Any}(\n    \"a\" => 1,\n    \"b\" => \"ccc\"\n)\n\nfrom_dict(MyOption, d)","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"now if we define the following type conversion","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"Configurations.from_dict(::Type{MyOption}, ::Type{Symbol}, s) = Symbol(s)","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"it will just work","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"from_dict(MyOption, d)","category":"page"}]
}
