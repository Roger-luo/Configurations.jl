<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick Start · Configurations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Roger-luo.github.io/Configurations.jl/quick-start/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Configurations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Quick Start</a><ul class="internal"><li><a class="tocitem" href="#Create-an-option-type"><span>Create an option type</span></a></li><li><a class="tocitem" href="#Create-pretty-printing-for-your-option-type"><span>Create pretty printing for your option type</span></a></li><li><a class="tocitem" href="#Read-from-Keyword-Arguments"><span>Read from Keyword Arguments</span></a></li><li><a class="tocitem" href="#Read-from-TOML-files"><span>Read from TOML files</span></a></li><li><a class="tocitem" href="#Read-from-YAML-files"><span>Read from YAML files</span></a></li><li><a class="tocitem" href="#Read-JSON-files"><span>Read JSON files</span></a></li><li><a class="tocitem" href="#Read-other-formats"><span>Read other formats</span></a></li><li><a class="tocitem" href="#Write-to-TOML"><span>Write to TOML</span></a></li><li><a class="tocitem" href="#Write-to-YAML"><span>Write to YAML</span></a></li><li><a class="tocitem" href="#Write-to-JSON"><span>Write to JSON</span></a></li><li><a class="tocitem" href="#Write-to-other-formats"><span>Write to other formats</span></a></li><li><a class="tocitem" href="#Work-with-StructTypes-and-JSON3"><span>Work with <code>StructTypes</code> and <code>JSON3</code></span></a></li><li><a class="tocitem" href="#Type-Conversion"><span>Type Conversion</span></a></li></ul></li><li><a class="tocitem" href="../convert/">Type Conversion</a></li><li><a class="tocitem" href="../advance/">Advanced Usage</a></li><li><a class="tocitem" href="../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick Start</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick Start</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Roger-luo/Configurations.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h1><h2 id="Create-an-option-type"><a class="docs-heading-anchor" href="#Create-an-option-type">Create an option type</a><a id="Create-an-option-type-1"></a><a class="docs-heading-anchor-permalink" href="#Create-an-option-type" title="Permalink"></a></h2><p>Create an option type with macro <code>@option</code> as following</p><pre><code class="language-julia hljs">@option struct YouOptionType &lt;: YourAbstractType
   a::Int = 1
   b::Float64 # required field
end</code></pre><p>then you can use this as an option type, it can let you:</p><ol><li>convert an option type defined in Julia to a markup language, such as TOML, JSON</li><li>read from plain <code>AbstractDict{String}</code>, TOML, JSON etc. and convert the data to the option type</li><li>compose several option types together</li></ol><p>You can easily create hierarchical struct types as following</p><pre><code class="language-julia hljs">julia&gt; &quot;Option A&quot;
       @option &quot;option_a&quot; struct OptionA
           name::String
           int::Int = 1
       end

julia&gt; &quot;Option B&quot;
       @option &quot;option_b&quot; struct OptionB
           opt::OptionA = OptionA(;name = &quot;Sam&quot;)
           float::Float64 = 0.3
       end</code></pre><p>and convert a dict to an option type via <a href="../ref/#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T}, AbstractDict{String, V} where V}} where T"><code>from_dict</code></a>.</p><pre><code class="language-julia hljs">julia&gt; d = Dict{String, Any}(
           &quot;opt&quot; =&gt; Dict{String, Any}(
               &quot;name&quot; =&gt; &quot;Roger&quot;,
               &quot;int&quot; =&gt; 2,
           ),
           &quot;float&quot; =&gt; 0.33
       );

julia&gt; option = from_dict(OptionB, d)
OptionB(;
    opt = OptionA(;
        name = &quot;Roger&quot;,
        int = 2,
    ),
    float = 0.33,
)</code></pre><p>when there are multiple possible option type for one field, one can use the alias to distinguish them</p><pre><code class="language-julia hljs">julia&gt; @option struct OptionD
           opt::Union{OptionA, OptionB}
       end

julia&gt; d1 = Dict{String, Any}(
               &quot;opt&quot; =&gt; Dict{String, Any}(
                   &quot;option_b&quot; =&gt; d
               )
           );

julia&gt; from_dict(OptionD, d1)
OptionD(;
    opt = OptionB(;
        opt = OptionA(;
            name = &quot;Roger&quot;,
            int = 2,
        ),
        float = 0.33,
    ),
)

julia&gt; using Configurations

julia&gt; @option struct OptionA
           name::String
           int::Int = 1
       end

julia&gt; @option struct OptionB
           opt::OptionA = OptionA(;name = &quot;Sam&quot;)
           float::Float64 = 0.3
       end

julia&gt; d = Dict(
           &quot;opt&quot; =&gt; Dict(
               &quot;name&quot; =&gt; &quot;Roger&quot;,
               &quot;int&quot; =&gt; 2,
           ),
           &quot;float&quot; =&gt; 0.33
       )
Dict{String, Any} with 2 entries:
  &quot;opt&quot;   =&gt; Dict{String, Any}(&quot;int&quot;=&gt;2, &quot;name&quot;=&gt;&quot;Roger&quot;)
  &quot;float&quot; =&gt; 0.33

julia&gt; option = from_dict(OptionB, d)
OptionB(;
  opt = OptionA(;
    name = &quot;Roger&quot;,
    int = 2,
  ),
  float = 0.33,
)</code></pre><p>Or you can also create it from keyword arguments, e.g</p><pre><code class="language-julia hljs">julia&gt; from_kwargs(OptionB; opt_name=&quot;Roger&quot;, opt_int=2, float=0.33)
OptionB(;
    opt = OptionA(;
        name = &quot;Roger&quot;,
        int = 2,
    ),
    float = 0.33,
)</code></pre><p>for option types you can always convert <code>AbstractDict</code> to a given option type, or convert them back to dictionary via <code>to_dict</code>, e.g</p><pre><code class="language-julia hljs">julia&gt; Configurations.to_dict(option)
OrderedDict{String, Any} with 2 entries:
  &quot;opt&quot;   =&gt; OrderedDict{String, Any}(&quot;name&quot;=&gt;&quot;Roger&quot;, &quot;int&quot;=&gt;2)
  &quot;float&quot; =&gt; 0.33</code></pre><p>for serialization, you can use the builtin TOML support</p><pre><code class="language-julia hljs">julia&gt; to_toml(option)
&quot;float = 0.33\n\n[opt]\nname = \&quot;Roger\&quot;\nint = 2\n&quot;</code></pre><p>Or serialize it to other format from <code>OrderedDict</code>.</p><h2 id="Create-pretty-printing-for-your-option-type"><a class="docs-heading-anchor" href="#Create-pretty-printing-for-your-option-type">Create pretty printing for your option type</a><a id="Create-pretty-printing-for-your-option-type-1"></a><a class="docs-heading-anchor-permalink" href="#Create-pretty-printing-for-your-option-type" title="Permalink"></a></h2><p>One can overload the <code>Base.show</code> method to create your own pretty printing. However, if you are fine with the printing style provided by <a href="https://rogerluo.dev/GarishPrint.jl/dev/">GarishPrint</a>, you can simply define the following</p><pre><code class="language-julia hljs"># using GarishPrint
Base.show(io::IO, ::MIME&quot;text/plain&quot;, x::MyOption) = GarishPrint.pprint_struct(io, x)</code></pre><p>This will enable pretty printing provided by <code>GarishPrint</code> when a rich text environment is available, and it will fallback to the default julia printing if <code>&quot;text/plain&quot;</code> <a href="https://en.wikipedia.org/wiki/Media_type">MIME type</a> is not available.</p><h2 id="Read-from-Keyword-Arguments"><a class="docs-heading-anchor" href="#Read-from-Keyword-Arguments">Read from Keyword Arguments</a><a id="Read-from-Keyword-Arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Read-from-Keyword-Arguments" title="Permalink"></a></h2><p>Option types can be used to organize large number of keyword arguments, and one can also construct an option type from keyword arguments via <a href="#Configurations.from_kwargs"><code>from_kwargs</code></a></p><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_kwargs" href="#Configurations.from_kwargs"><code>Configurations.from_kwargs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_kwargs(convention!, ::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using <code>convention!</code>. See also <a href="#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T}, AbstractDict{String, V} where V}} where T"><code>from_dict</code></a>.</p><p><strong>Convention</strong></p><ul><li><code>from_underscore_kwargs!</code>: use <code>_</code> to disambiguate subfields of the same name, this is the default behaviour.</li><li><code>from_field_kwargs!</code>: do not disambiguate subfields, errors if there are disambiguity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section><section><div><pre><code class="language-julia hljs">from_kwargs(::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using the underscore convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><p>A real world example is <a href="https://github.com/fonsp/Pluto.jl/blob/main/src/Configuration.jl#L159">the Pluto configuration</a>.</p><h2 id="Read-from-TOML-files"><a class="docs-heading-anchor" href="#Read-from-TOML-files">Read from TOML files</a><a id="Read-from-TOML-files-1"></a><a class="docs-heading-anchor-permalink" href="#Read-from-TOML-files" title="Permalink"></a></h2><p>Configurations supports TOML file by default via the TOML standard library, you can directly read a TOML file to your option types via <a href="#Configurations.from_toml"><code>from_toml</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_toml" href="#Configurations.from_toml"><code>Configurations.from_toml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">from_toml(::Type{T}, filename::String; kw...) where T</code></pre><p>Convert a given TOML file <code>filename</code> to an option type <code>T</code>. Valid fields can be override by keyword arguments. See also <a href="#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T}, AbstractDict{String, V} where V}} where T"><code>from_dict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><h2 id="Read-from-YAML-files"><a class="docs-heading-anchor" href="#Read-from-YAML-files">Read from YAML files</a><a id="Read-from-YAML-files-1"></a><a class="docs-heading-anchor-permalink" href="#Read-from-YAML-files" title="Permalink"></a></h2><p>You can use the <a href="https://github.com/JuliaData/YAML.jl">JuliaData/YAML</a> package to parse a YAML file to a <code>Dict{String, Any}</code>,</p><pre><code class="language-julia hljs">julia&gt; using YAML, Configurations

julia&gt; @option struct MyOption
           a::Int
           b::Float64
       end

julia&gt; data = YAML.load_file(&quot;test.yml&quot;; dicttype=Dict{String, Any})
Dict{String, Any} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; from_dict(MyOption, data)
MyOption(1, 2.0)</code></pre><p>but remember to tell the YAML parser that you would like the keys to be <code>String</code> since <a href="../ref/#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T}, AbstractDict{String, V} where V}} where T"><code>from_dict</code></a> expects the dictionary to be <code>AbstractDict{String}</code>, this can be done via <code>dicttype</code> keyword as above example.</p><h2 id="Read-JSON-files"><a class="docs-heading-anchor" href="#Read-JSON-files">Read JSON files</a><a id="Read-JSON-files-1"></a><a class="docs-heading-anchor-permalink" href="#Read-JSON-files" title="Permalink"></a></h2><p>One can read JSON files as a dictionary via <a href="https://github.com/JuliaIO/JSON.jl">JuliaIO/JSON</a>.</p><pre><code class="language-julia hljs">julia&gt; using JSON

julia&gt; d = JSON.parse(&quot;{\&quot;a\&quot;:1,\&quot;b\&quot;:2.1}&quot;)
Dict{String, Any} with 2 entries:
  &quot;b&quot; =&gt; 2.1
  &quot;a&quot; =&gt; 1

julia&gt; from_dict(MyOption, d)
MyOption(1, 2.1)</code></pre><p>or for <a href="https://github.com/quinnj/JSON3.jl">JSON3</a> you can use the following</p><pre><code class="language-julia hljs">julia&gt; using JSON3, Configurations

julia&gt; @option struct OptionA
        x::String = &quot;hi&quot;
        y::Vector{String} = String[]
           end

julia&gt; d = JSON3.read(&quot;&quot;&quot;
           {&quot;y&quot;: [&quot;a&quot;]}
           &quot;&quot;&quot;, Dict{String, Any})
Dict{String, Any} with 1 entry:
  &quot;y&quot; =&gt; Any[&quot;a&quot;]

julia&gt; from_dict(OptionA, d)
OptionA(&quot;hi&quot;, [&quot;a&quot;])</code></pre><h2 id="Read-other-formats"><a class="docs-heading-anchor" href="#Read-other-formats">Read other formats</a><a id="Read-other-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Read-other-formats" title="Permalink"></a></h2><p>For other formats, as long as you can convert them to a subtype of <code>AbstractDict{String}</code>, you can always convert it to the option type you just defined via <code>from_dict</code>, however for the sake of simplicity Configurations will not ship such functionality with it.</p><h2 id="Write-to-TOML"><a class="docs-heading-anchor" href="#Write-to-TOML">Write to TOML</a><a id="Write-to-TOML-1"></a><a class="docs-heading-anchor-permalink" href="#Write-to-TOML" title="Permalink"></a></h2><p>To write the option struct to a TOML file, simply use the <code>to_toml</code> function</p><pre><code class="language-julia hljs">julia&gt; to_toml(option; include_defaults=false) # write to a String

julia&gt; to_toml(&quot;test.toml&quot;, option; include_defaults=false) # write to a file</code></pre><p>You may also be interested in the docstring of <code>to_toml</code></p><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_toml" href="#Configurations.to_toml"><code>Configurations.to_toml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>option</code> of option type to TOML and write it to <code>IO</code>. See <a href="../quick-start/#Configurations.to_dict"><code>to_dict</code></a> for other valid keyword options. See also <code>TOML.print</code> in the stdlib for the explaination of <code>sorted</code>, <code>by</code> and <code>f</code>.</p><p><strong>Exclude <code>nothing</code></strong></p><p>In TOML specification, there is <a href="https://github.com/toml-lang/toml/issues/802">no null type</a>. One should exclude the field if it is not specified (of value <code>nothing</code> in Julia). In <code>to_toml</code> the option <code>exclude_nothing</code> is always <code>true</code>.</p><p>In most cases, <code>nothing</code> is used with another type to denote optional or not specified field, thus one should always put a default value <code>nothing</code> to the option struct, e.g</p><p>One should define</p><pre><code class="language-julia hljs">@option struct OptionX
    a::Union{Nothing, Int} = nothing
    b::Maybe{Int} = nothing
end</code></pre><p>Here <code>Maybe{T}</code> is a convenient alias of <code>Union{Nothing, T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section><section><div><pre><code class="language-julia hljs">to_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>option</code> of option type to TOML and write it to <code>filename</code>. See also <code>TOML.print</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section><section><div><pre><code class="language-julia hljs">to_toml(x; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>x</code> of option type to TOML and write it to <code>String</code>. See also <code>TOML.print</code>. </p><p><code>to_toml</code> does not export fields that are of the same values as the defaults. This can be  overridden by changing <code>include_defaults</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><h2 id="Write-to-YAML"><a class="docs-heading-anchor" href="#Write-to-YAML">Write to YAML</a><a id="Write-to-YAML-1"></a><a class="docs-heading-anchor-permalink" href="#Write-to-YAML" title="Permalink"></a></h2><p>To write the option struct to other formats, you need to convert it to a dictionary type first via <code>to_dict</code></p><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_dict" href="#Configurations.to_dict"><code>Configurations.to_dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_dict(x; include_defaults=true, exclude_nothing=false) -&gt; OrderedDict</code></pre><p>Convert an object <code>x</code> to an <code>OrderedDict</code>.</p><p><strong>Kwargs</strong></p><ul><li><code>include_defaults</code>: include the default value, default is <code>true</code>.</li><li><code>exclude_nothing</code>: exclude fields that have value <code>nothing</code>,   this supersedes <code>include_defaults</code> when they are both <code>true</code>.</li></ul><p><strong>Format Compatibilty</strong></p><p>When mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as <a href="#Configurations.TOMLStyle"><code>TOMLStyle</code></a>, <a href="#Configurations.YAMLStyle"><code>YAMLStyle</code></a>, <a href="#Configurations.JSONStyle"><code>JSONStyle</code></a>.</p><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p><code>to_dict</code> does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use <code>include_defaults</code>, however,  this can be overridden by changing <code>include_defaults</code> to <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section><section><div><pre><code class="language-julia hljs">to_dict(x, option::ToDictOption) -&gt; OrderedDict</code></pre><p>Convert an object <code>x</code> to an <code>OrderedDict</code> with <code>ToDictOption</code> specified.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">to_dict(x, TOMLStyle) # TOML compatible
to_dict(x, YAMLStyle) # YAML compatible
to_dict(x, JSONStyle) # JSON compatible</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section><section><div><pre><code class="language-julia hljs">to_dict(::Type{T}, x, option::ConvertOption) where T</code></pre><p>Convert <code>x</code> when <code>x</code> is inside an option type <code>T</code>. <code>option</code> is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of <code>to_dict(x; kw...)</code>.</p><pre><code class="nohighlight hljs">to_dict(::Type{T}, x) where T</code></pre><p>One can also use the 2-arg version when <code>x</code> is not or does not contain an option type for convenience.</p><p><strong>Example</strong></p><p>The following is a builtin overload to handle list of options.</p><pre><code class="language-julia hljs">function Configurations.to_dict(::Type{T}, x::Vector, option::ConvertOption) where T
    if is_option(eltype(x))
        return map(p-&gt;to_dict(T, p, include_defaults), x)
    else
        return x
    end
end</code></pre><p>The following overloads the 2-arg <code>to_dict</code> to convert all <code>VersionNumber</code> to a <code>String</code> for all kinds of option types.</p><pre><code class="language-julia hljs">Configurations.to_dict(::Type, x::VersionNumber) = string(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><p>Then you can use YAML package to write the dict to a YAML file</p><pre><code class="language-julia hljs">julia&gt; using YAML, Configurations

julia&gt; d = to_dict(your_option, YAMLStyle)

julia&gt; YAML.write_file(&quot;myfile.yaml&quot;, d)</code></pre><h2 id="Write-to-JSON"><a class="docs-heading-anchor" href="#Write-to-JSON">Write to JSON</a><a id="Write-to-JSON-1"></a><a class="docs-heading-anchor-permalink" href="#Write-to-JSON" title="Permalink"></a></h2><p>or for JSON, we recommend using <a href="https://github.com/JuliaIO/JSON.jl">JSON</a> or <a href="https://github.com/quinnj/JSON3.jl">JSON3</a> to write the file as following</p><p>for <code>JSON</code></p><pre><code class="language-julia hljs">julia&gt; using JSON, Configurations

julia&gt; d = to_dict(your_option, JSONStyle)

julia&gt; open(&quot;file.json&quot;, &quot;w&quot;) do f
           JSON.print(f, d)
       end</code></pre><p>for <code>JSON3</code> you can use the following code snippet</p><pre><code class="language-julia hljs">julia&gt; using JSON3, Configurations

julia&gt; @option struct OptionA
        x::String = &quot;hi&quot;
        y::Vector{String} = String[]
    end

julia&gt; d = to_dict(OptionA(y=[&quot;a&quot;]))

julia&gt; JSON3.write(d)
&quot;{\&quot;x\&quot;:\&quot;hi\&quot;,\&quot;y\&quot;:[\&quot;a\&quot;]}&quot;

julia&gt; JSON3.write(&quot;file.json&quot;, d) # write to a file
&quot;file.json&quot;</code></pre><h2 id="Write-to-other-formats"><a class="docs-heading-anchor" href="#Write-to-other-formats">Write to other formats</a><a id="Write-to-other-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Write-to-other-formats" title="Permalink"></a></h2><p>For other formats, you can convert your option struct to an <code>OrderedDict{String, Any}</code> via <a href="#Configurations.to_dict"><code>to_dict</code></a> then serialize the dictionary to your desired format.</p><h2 id="Work-with-StructTypes-and-JSON3"><a class="docs-heading-anchor" href="#Work-with-StructTypes-and-JSON3">Work with <code>StructTypes</code> and <code>JSON3</code></a><a id="Work-with-StructTypes-and-JSON3-1"></a><a class="docs-heading-anchor-permalink" href="#Work-with-StructTypes-and-JSON3" title="Permalink"></a></h2><p>One can work with <a href="https://github.com/JuliaData/StructTypes.jl"><code>StructType</code></a> with <code>Configurations</code> to make <code>JSON.read(json_string, MyOptionType)</code> work automatically by copying the following code and replace <code>MyOptionType</code> with your own option struct types.</p><pre><code class="language-julia hljs">using StructTypes
using Configurations
StructTypes.StructType(::Type{&lt;:MyOptionType}) = StructTypes.CustomStruct()
StructTypes.lower(x::MyOptionType) = to_dict(x, JSONStyle)
StructTypes.lowertype(::Type{&lt;:MyOptionType}) = OrderedDict{String, Any}
StructTypes.construct(::Type{T}, x) where {T &lt;: MyOptionType} = from_dict(T, x)</code></pre><p>then <code>JSON.read(&quot;// a json string or IO&quot;, MyOptionType)</code> will just work.</p><h2 id="Type-Conversion"><a class="docs-heading-anchor" href="#Type-Conversion">Type Conversion</a><a id="Type-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Conversion" title="Permalink"></a></h2><p>Since markup languages usually do not support arbitrary Julia types, thus, one may find the <code>from_dict</code> complain that cannot <code>convert</code> an object of type <code>XXX</code> to an object of type <code>YYY</code>. Usually this is because you haven&#39;t overload <code>Base.convert</code> from <code>XXX</code> to <code>YYY</code> for the custom struct type, usually this can be resolved via the following overload</p><pre><code class="language-julia hljs">Base.convert(::Type{MyType}, x::String) = MyType(x)</code></pre><p>where we assume you have written a constructor from <code>String</code> here.</p><p>However, in some cases, you may want to do the conversion only for one <code>OptionType</code> without causing type piracy, for example, one may want to convert all the <code>String</code> to <code>Symbol</code> for <code>MyOption</code>, this can be done by overloading <a href="../ref/#Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T"><code>Configurations.convert_to_option</code></a></p><pre><code class="language-julia hljs">Configurations.convert_to_option(::Type{MyOption}, ::Type{Symbol}, s) = Symbol(s)</code></pre><p>For more detailed type conversion mechanism, please read the <a href="../convert/#type-conversion">Type Conversion</a> section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../convert/">Type Conversion »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Saturday 9 October 2021 18:56">Saturday 9 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
