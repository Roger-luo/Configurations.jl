var documenterSearchIndex = {"docs":
[{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"CurrentModule = Configurations","category":"page"},{"location":"advance/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"For most use cases, the default API @option is sufficient, however, there are some specific cases requires one to use Configurations's advanced API.","category":"page"},{"location":"advance/#Reflect-Type","page":"Advanced Usage","title":"Reflect Type","text":"","category":"section"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"One can use Reflect type to denote a field contains the type information of the struct.","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"Reflect","category":"page"},{"location":"advance/#Configurations.Reflect","page":"Advanced Usage","title":"Configurations.Reflect","text":"Reflect\n\nPlaceholder type for reflected type string.\n\nType Alias\n\nif the corresponding type has a type_alias defined, serialization and parsing will use the type_alias instead of the type name, this only works on concrete types since the alias cannot contain any type var information.\n\nExample\n\nthe following option struct\n\n@option struct MyOption\n    type::Reflect\n    name::String = \"Sam\"\nend\n\nwould be equivalent to\n\ntype = \"MyOption\"\nname = \"Sam\"\n\nthis is useful for defining list of different types etc.\n\n\n\n\n\n","category":"type"},{"location":"advance/#Alias","page":"Advanced Usage","title":"Alias","text":"","category":"section"},{"location":"advance/#Option-Type-Alias","page":"Advanced Usage","title":"Option Type Alias","text":"","category":"section"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"When there are multiple possible choices for an option-typed field, e.g","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"@option struct Options\n    options::Union{OptionA, OptionB}\nend","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"where OptionA and OptionB are also option types, one can specific which option type is it by using an alias when defining OptionA and OptionB","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"@option \"A\" struct OptionA\n    name::String\nend\n\n@option \"B\" struct OptionB\n    age::Int\nend","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"then you can create an Options from the following Julia Dict","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"Dict{String, Any}(\n    \"options\" => Dict{String, Any}(\n        \"A\" => Dict{String, Any}(\n            \"name\"=>\"Roger\",\n        )\n    )\n)","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"or by using the following TOML file,","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"[options.A]\nname=\"Roger\"","category":"page"},{"location":"advance/#Custom-Option-Macro","page":"Advanced Usage","title":"Custom Option Macro","text":"","category":"section"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"In some cases, you may not want all the features we defined by default in Configurations, such as the printing, etc.","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"In this case, you can construct your own macro using the code generation passes defined in Configurations. The code generation passes API starts with codegen_.","category":"page"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"Configurations uses an intermediate representation defined by Expronicon to represent user defined option types, which is the JLKwStruct struct.","category":"page"},{"location":"advance/#Builtin-Code-Generator","page":"Advanced Usage","title":"Builtin Code Generator","text":"","category":"section"},{"location":"advance/","page":"Advanced Usage","title":"Advanced Usage","text":"codegen_create\ncodegen_is_option\ncodegen_convert\ncodegen_field_default\ncodegen_type_alias\ncodegen_isequal","category":"page"},{"location":"advance/#Configurations.codegen_create","page":"Advanced Usage","title":"Configurations.codegen_create","text":"codegen_create(def::JLKwStruct)\n\nGenerate Configurations.create overload.\n\n\n\n\n\n","category":"function"},{"location":"advance/#Configurations.codegen_is_option","page":"Advanced Usage","title":"Configurations.codegen_is_option","text":"codegen_is_option(x::JLKwStruct)\n\nGenerate the is_option method.\n\n\n\n\n\n","category":"function"},{"location":"advance/#Configurations.codegen_convert","page":"Advanced Usage","title":"Configurations.codegen_convert","text":"codegen_convert(x::JLKwStruct)\n\nGenerate Base.convert from AbstractDict{String} to the given option type.\n\n\n\n\n\n","category":"function"},{"location":"advance/#Configurations.codegen_field_default","page":"Advanced Usage","title":"Configurations.codegen_field_default","text":"codegen_field_default(def::JLKwStruct)\n\nGenerate field_default overload to support the default value reflection.\n\n\n\n\n\n","category":"function"},{"location":"advance/#Configurations.codegen_type_alias","page":"Advanced Usage","title":"Configurations.codegen_type_alias","text":"codegen_type_alias(def::JLKwStruct)\n\nGenerate type alias method type_alias.\n\n\n\n\n\n","category":"function"},{"location":"advance/#Configurations.codegen_isequal","page":"Advanced Usage","title":"Configurations.codegen_isequal","text":"codegen_isequal(x::JLKwStruct)\n\nGenerate Base.:(==) to overload comparison operator to compare_options for given option type.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"CurrentModule = Configurations","category":"page"},{"location":"ref/#Reference","page":"References","title":"Reference","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Modules = [Configurations]","category":"page"},{"location":"ref/#Configurations.JSONStyle","page":"References","title":"Configurations.JSONStyle","text":"JSONStyle::ToDictOption\n\nPredefined option for JSON compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.Maybe","page":"References","title":"Configurations.Maybe","text":"maybe of type T or nothing\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.TOMLStyle","page":"References","title":"Configurations.TOMLStyle","text":"TOMLStyle::ToDictOption\n\nPredefined option for TOML compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.YAMLStyle","page":"References","title":"Configurations.YAMLStyle","text":"YAMLStyle::ToDictOption\n\nPredefined option for YAML compatible to_dict option.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Configurations.ConvertNotFound","page":"References","title":"Configurations.ConvertNotFound","text":"ConvertNotFound\n\nConversion is not defined via convert_to_option. One should let the conversion fallback to Base.convert when see this.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.DuplicatedFieldError","page":"References","title":"Configurations.DuplicatedFieldError","text":"DuplicatedFieldError(name, type)\n\nA field with name of given option type is duplicated in the subfields option type. Thus one cannot use the field keyword convention when seeing this error.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.PartialDefault","page":"References","title":"Configurations.PartialDefault","text":"PartialDefault{F}\n\nType for non-constant default value, it depends on the value of another field that has default value.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Configurations.codegen_convert-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_convert","text":"codegen_convert(x::JLKwStruct)\n\nGenerate Base.convert from AbstractDict{String} to the given option type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_create-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_create","text":"codegen_create(def::JLKwStruct)\n\nGenerate Configurations.create overload.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_field_default-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_field_default","text":"codegen_field_default(def::JLKwStruct)\n\nGenerate field_default overload to support the default value reflection.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_is_option-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_is_option","text":"codegen_is_option(x::JLKwStruct)\n\nGenerate the is_option method.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_isequal-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_isequal","text":"codegen_isequal(x::JLKwStruct)\n\nGenerate Base.:(==) to overload comparison operator to compare_options for given option type.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_option_type-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_option_type","text":"codegen_option_type(def::JLKwStruct)\n\nGenerate the Configurations option type definition from a given JLKwStruct created by Expronicon.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.codegen_type_alias-Tuple{ExproniconLite.JLKwStruct}","page":"References","title":"Configurations.codegen_type_alias","text":"codegen_type_alias(def::JLKwStruct)\n\nGenerate type alias method type_alias.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.compare_options-Tuple{Any, Any, Vararg{Any, N} where N}","page":"References","title":"Configurations.compare_options","text":"compare_options(a, b, xs...)::Bool\n\nCompare option types check if they are the same.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T","page":"References","title":"Configurations.convert_to_option","text":"convert_to_option(::Type{OptionType}, ::Type{ValueType}, x) where {OptionType, ValueType}\n\nConvert x to type ValueType for option type OptionType. This is similar to Base.convert, but will not error if the conversion is not overloaded, and will return a ConvertNotFound object, but one can use this to avoid type piracy and define contextual conversion based on option types.\n\nExample\n\nOne may have different string syntax for a Symbol, e.g\n\n@option struct StringIsSymbol\n    name::Symbol\nend\n\n@option struct SymbolNeedsColon\n    name::Symbol\nend\n\nConfigurations.convert_to_option(::Type{StringIsSymbol}, ::Type{Symbol}, x::String) = Symbol(x)\n\nfunction Configurations.convert_to_option(::Type{SymbolNeedsColon}, ::Type{Symbol}, x::String)\n    if startswith(x, ':')\n        Symbol(x[2:end])\n    else\n        error(\"expect a Symbol, got String\")\n    end\nend\n\nthen if we run it, we will have different behaviour by context.\n\njulia> from_dict(StringIsSymbol, d)\nStringIsSymbol(:ccc)\n\njulia> from_dict(SymbolNeedsColon, d)\nERROR: expect a Symbol, got String\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.create-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.create","text":"create(::Type{T}; kwargs...) where T\n\nCreate an instance of option type T from kwargs. Similar to the default keyword argument constructor, but one can use this to create custom keyword argument constructor with extra custom keywords.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_default-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T","page":"References","title":"Configurations.field_default","text":"field_default(::Type{T}, name::Symbol)\n\nReturn the default value of field name of an option type T.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_defaults-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.field_defaults","text":"field_defaults(::Type)\n\nReturn default values of given option types.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.field_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.field_keywords","text":"field_keywords(::Type{T}) where T\n\nReturn all the option type field names given T, error if there are duplicated sub-fields.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict-Union{Tuple{T}, Tuple{Type{T}, AbstractDict{String, V} where V}} where T","page":"References","title":"Configurations.from_dict","text":"from_dict(::Type{T}, d::AbstractDict{String}; kw...) where T\n\nConvert dictionary d to an option type T, the value of valid fields of T in this dictionary d can be override by keyword arguments.\n\nExample\n\njulia> @option struct OptionA\n           name::String = \"Sam\"\n           age::Int = 25\n       end\n\njulia> d = Dict{String, Any}(\n           \"name\" => \"Roger\",\n           \"age\" => 10,\n       );\n\njulia> from_dict(OptionA, d; age=25)\nOptionA(;\n    name = \"Roger\",\n    age = 25,\n)\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_dict_inner-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Bool}} where T","page":"References","title":"Configurations.from_dict_inner","text":"from_dict_inner(::Type{T}, d::AbstractDict{String}) where T\n\nInternal method to convert a dictionary (subtype of AbstractDict) to type T, this method will not check if T is an option type via is_option, and will not validate if all the required fields are available in the dict object.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_field_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_field_kwargs","text":"from_field_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the field keyword convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs!-Union{Tuple{T}, Tuple{AbstractDict{String, V} where V, Type{T}}, Tuple{AbstractDict{String, V} where V, Type{T}, Union{Nothing, Symbol}}} where T","page":"References","title":"Configurations.from_kwargs!","text":"from_kwargs!(d::AbstractDict{String}, ::Type{T}, prefix::Maybe{Symbol} = nothing; kw...) where T\n\nInternal method for inserting keyword arguments to given dictionary object d. It will overwrite existing keys in d if it is specified by keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_kwargs","text":"from_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_kwargs-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"References","title":"Configurations.from_kwargs","text":"from_kwargs(convention!, ::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using convention!. See also from_dict.\n\nConvention\n\nfrom_underscore_kwargs!: use _ to disambiguate subfields of the same name, this is the default behaviour.\nfrom_field_kwargs!: do not disambiguate subfields, errors if there are disambiguity\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_toml-Union{Tuple{T}, Tuple{Type{T}, String}} where T","page":"References","title":"Configurations.from_toml","text":"from_toml(::Type{T}, filename::String; kw...) where T\n\nConvert a given TOML file filename to an option type T. Valid fields can be override by keyword arguments. See also from_dict.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_toml_if_exists-Union{Tuple{T}, Tuple{Type{T}, String}} where T","page":"References","title":"Configurations.from_toml_if_exists","text":"from_toml_if_exists(::Type{T}, filename::String; kw...) where T\n\nSimilar to from_toml but will create the option instance via from_kwargs(T;kw...) instead of error if the file does not exist.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.from_underscore_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.from_underscore_kwargs","text":"from_underscore_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.is_option-Tuple{Any}","page":"References","title":"Configurations.is_option","text":"is_option(x)\n\nCheck if x is an option type or not.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.is_option_maybe-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.is_option_maybe","text":"is_option_maybe(::Type{T}) where T\n\nT is an option struct or if T is an union, one of the types is an option struct.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.pick_union-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"References","title":"Configurations.pick_union","text":"pick_union(::Type, x) -> type, value\n\nPick a type T and its corresponding value from a Union. For option types it should be a dictionary type. The value can be furthur converted to this type T via convert_to_option or Base.convert.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Tuple{Any, Configurations.ToDictOption}","page":"References","title":"Configurations.to_dict","text":"to_dict(x, option::ToDictOption) -> OrderedDict\n\nConvert an object x to an OrderedDict with ToDictOption specified.\n\nExample\n\nto_dict(x, TOMLStyle) # TOML compatible\nto_dict(x, YAMLStyle) # YAML compatible\nto_dict(x, JSONStyle) # JSON compatible\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Tuple{Any}","page":"References","title":"Configurations.to_dict","text":"to_dict(x; include_defaults=true, exclude_nothing=false) -> OrderedDict\n\nConvert an object x to an OrderedDict.\n\nKwargs\n\ninclude_defaults: include the default value, default is true.\nexclude_nothing: exclude fields that have value nothing,   this supersedes include_defaults when they are both true.\n\nFormat Compatibilty\n\nWhen mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as TOMLStyle, YAMLStyle, JSONStyle.\n\ntips: Tips\nto_dict does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use include_defaults, however,  this can be overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_dict-Union{Tuple{T}, Tuple{Type{T}, Any, Configurations.ToDictOption}} where T","page":"References","title":"Configurations.to_dict","text":"to_dict(::Type{T}, x, option::ConvertOption) where T\n\nConvert x when x is inside an option type T. option is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of to_dict(x; kw...).\n\nto_dict(::Type{T}, x) where T\n\nOne can also use the 2-arg version when x is not or does not contain an option type for convenience.\n\nExample\n\nThe following is a builtin overload to handle list of options.\n\nfunction Configurations.to_dict(::Type{T}, x::Vector, option::ConvertOption) where T\n    if is_option(eltype(x))\n        return map(p->to_dict(T, p, include_defaults), x)\n    else\n        return x\n    end\nend\n\nThe following overloads the 2-arg to_dict to convert all VersionNumber to a String for all kinds of option types.\n\nConfigurations.to_dict(::Type, x::VersionNumber) = string(x)\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any, IO, Any}","page":"References","title":"Configurations.to_toml","text":"to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to IO. See to_dict for other valid keyword options. See also TOML.print in the stdlib for the explaination of sorted, by and f.\n\nExclude nothing\n\nIn TOML specification, there is no null type. One should exclude the field if it is not specified (of value nothing in Julia). In to_toml the option exclude_nothing is always true.\n\nIn most cases, nothing is used with another type to denote optional or not specified field, thus one should always put a default value nothing to the option struct, e.g\n\nOne should define\n\n@option struct OptionX\n    a::Union{Nothing, Int} = nothing\n    b::Maybe{Int} = nothing\nend\n\nHere Maybe{T} is a convenient alias of Union{Nothing, T}.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any, String, Any}","page":"References","title":"Configurations.to_toml","text":"to_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to filename. See also TOML.print.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.to_toml-Tuple{Any}","page":"References","title":"Configurations.to_toml","text":"to_toml(x; sorted=false, by=identity, kw...)\n\nConvert an instance x of option type to TOML and write it to String. See also TOML.print. \n\nto_toml does not export fields that are of the same values as the defaults. This can be  overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.type_alias-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.type_alias","text":"type_alias(::Type{OptionType}) -> String\n\nReturn the alias name of given OptionType.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.underscore_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"References","title":"Configurations.underscore_keywords","text":"underscore_keywords(::Type{T}) where T\n\nReturn keywords given T using the underscore convention.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Configurations.@option-Tuple{Any}","page":"References","title":"Configurations.@option","text":"@option [alias::String] <struct def>\n\nDefine an option struct type. This will auto-generate methods that parse a given Dict{String} object (the keys must be of type String) into an instance of the struct type you defined. One can use alias string to distinguish multiple possible option type for the same field.\n\ncompat: Configurations 0.16\nfrom v0.16.0 Configurations stops overloading the Base.show method for you, if you need pretty printing of your option types, consider overloading the Base.show(io::IO, mime::MIME, x) method to pprint_struct(io, mime, x) provided by GarishPrint\n\ncompat: Configurations 0.12\nfrom v0.12.0 the field alias feature is removed due to the syntax conflict with field docstring. Please refer to #17.\n\nExample\n\nOne can define option type via @option macro with or without an alias.\n\njulia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\nand convert a dict to an option type via from_dict.\n\njulia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)\n\nwhen there are multiple possible option type for one field, one can use the alias to distinguish them\n\njulia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\n\n\n\n\n","category":"macro"},{"location":"#Configurations","page":"Home","title":"Configurations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: codecov)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Configurations & Options made easy.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p>\nConfigurations is a &nbsp;\n    <a href=\"https://julialang.org\">\n        <img src=\"https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia.ico\" width=\"16em\">\n        Julia Language\n    </a>\n    &nbsp; package. To install Configurations,\n    please <a href=\"https://docs.julialang.org/en/v1/manual/getting-started/\">open\n    Julia's interactive session (known as REPL)</a> and press <kbd>]</kbd> key in the REPL to use the package mode, then type the following command\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Configurations","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a macro @option to let you define structs to represent options/configurations, and serialize between different option/configuration file format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@option","category":"page"},{"location":"#Configurations.@option","page":"Home","title":"Configurations.@option","text":"@option [alias::String] <struct def>\n\nDefine an option struct type. This will auto-generate methods that parse a given Dict{String} object (the keys must be of type String) into an instance of the struct type you defined. One can use alias string to distinguish multiple possible option type for the same field.\n\ncompat: Configurations 0.16\nfrom v0.16.0 Configurations stops overloading the Base.show method for you, if you need pretty printing of your option types, consider overloading the Base.show(io::IO, mime::MIME, x) method to pprint_struct(io, mime, x) provided by GarishPrint\n\ncompat: Configurations 0.12\nfrom v0.12.0 the field alias feature is removed due to the syntax conflict with field docstring. Please refer to #17.\n\nExample\n\nOne can define option type via @option macro with or without an alias.\n\njulia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\nand convert a dict to an option type via from_dict.\n\njulia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)\n\nwhen there are multiple possible option type for one field, one can use the alias to distinguish them\n\njulia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\n\n\n\n\n","category":"macro"},{"location":"#Frequently-Asked-Questions","page":"Home","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When should I use this package?","category":"page"},{"location":"","page":"Home","title":"Home","text":"When you have a lot settings/preferences/keyword arguments for a package or a function, or you need to validate a JSON schema, a REST API for your web server. A similar package in Python is pydantic in Python, but this package only provides the basic feature, a pydantic compatible package will be developed in the future in KungIChi.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A common type of code is instead of writing many keyword arguments, like foo(;kw_a=1, kw_b=2, kw_c, ...), wrap them in an option type","category":"page"},{"location":"","page":"Home","title":"Home","text":"@option struct FooOptions\n    kw_a::Int = 1\n    kw_b::Int = 2\n    # ...\nend\n\nfoo(x, y;kw...) = foo(x, y, FooOptions(;kw...))\nfoo(x, y, options::FooOptions) = #= actual implementation =#","category":"page"},{"location":"","page":"Home","title":"Home","text":"this will make your keyword argument easy to read and serialize with readable markup language like TOML.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why Configurations only supports TOML?","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is not true, Configurations supports converting a dictionary type (subtype of AbstractDict{String}) to option types defined by @option. The reason why TOML is supported by default is because Julia is shipped with a TOML parser already, so we can support TOML without adding extra dependency. And depending on other format parsers such as YAML, JSON etc. will cause an extra loading latency that is not necessary for most of the users who is fine with just TOML. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, Configurations aims to be lightweight because it is used by latency sensitive packages like Comonicon. We will put other features into KungIChi in the future (it is still work-in-progress).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why do you need an @option macro?","category":"page"},{"location":"","page":"Home","title":"Home","text":"the @option macro provides the functionality of reflection in compile time, e.g we support type alias and default value reflection. These feature is not implementable without macros.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Why not just use a supertype but a macro?","category":"page"},{"location":"","page":"Home","title":"Home","text":"besides the reason in the previous question, for a specific project, we can write a supertype and implement a set of generic interface, which is fine. But as a package, we need to make things composable and generic, thus, we do not want to block users from defining their own supertype. In this package, we use traits instead of supertypes, this makes things composable, e.g you can use the option types defined in Pluto as part of your own option types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is the difference between this package and Preferences","category":"page"},{"location":"","page":"Home","title":"Home","text":"Preferences aims to provide a mechanism of reading package preferences that works with the package manager Pkg, but this package aims to provide a mechnism to read a setting/preference to Julia structs. Thus these two are completely orthogonal packages and they can work together.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is the difference between this package and StructTypes","category":"page"},{"location":"","page":"Home","title":"Home","text":"StructTypes is mainly used to provide a standard interface to parse dict-like data to a Julia struct via traits to make parsing faster, but this package aims to support the mapping between a dict-like data and a specific kind of Julia struct defined by @option which provides limited semantic that is not as general as a normal Julia struct (it is closer to Base.@kwdef semantic). And we have plans of supporting StructTypes traits by default once JuliaData/StructTypes#53 is figured out.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License","category":"page"},{"location":"quick-start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick-start/#Create-an-option-type","page":"Quick Start","title":"Create an option type","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Create an option type with macro @option as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"@option struct YouOptionType <: YourAbstractType\n   a::Int = 1\n   b::Float64 # required field\nend","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"then you can use this as an option type, it can let you:","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"convert an option type defined in Julia to a markup language, such as TOML, JSON\nread from plain AbstractDict{String}, TOML, JSON etc. and convert the data to the option type\ncompose several option types together","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You can easily create hierarchical struct types as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> \"Option A\"\n       @option \"option_a\" struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> \"Option B\"\n       @option \"option_b\" struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"and convert a dict to an option type via from_dict.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> d = Dict{String, Any}(\n           \"opt\" => Dict{String, Any}(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       );\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"when there are multiple possible option type for one field, one can use the alias to distinguish them","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> @option struct OptionD\n           opt::Union{OptionA, OptionB}\n       end\n\njulia> d1 = Dict{String, Any}(\n               \"opt\" => Dict{String, Any}(\n                   \"option_b\" => d\n               )\n           );\n\njulia> from_dict(OptionD, d1)\nOptionD(;\n    opt = OptionB(;\n        opt = OptionA(;\n            name = \"Roger\",\n            int = 2,\n        ),\n        float = 0.33,\n    ),\n)\n\njulia> using Configurations\n\njulia> @option struct OptionA\n           name::String\n           int::Int = 1\n       end\n\njulia> @option struct OptionB\n           opt::OptionA = OptionA(;name = \"Sam\")\n           float::Float64 = 0.3\n       end\n\njulia> d = Dict(\n           \"opt\" => Dict(\n               \"name\" => \"Roger\",\n               \"int\" => 2,\n           ),\n           \"float\" => 0.33\n       )\nDict{String, Any} with 2 entries:\n  \"opt\"   => Dict{String, Any}(\"int\"=>2, \"name\"=>\"Roger\")\n  \"float\" => 0.33\n\njulia> option = from_dict(OptionB, d)\nOptionB(;\n  opt = OptionA(;\n    name = \"Roger\",\n    int = 2,\n  ),\n  float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Or you can also create it from keyword arguments, e.g","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> from_kwargs(OptionB; opt_name=\"Roger\", opt_int=2, float=0.33)\nOptionB(;\n    opt = OptionA(;\n        name = \"Roger\",\n        int = 2,\n    ),\n    float = 0.33,\n)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for option types you can always convert AbstractDict to a given option type, or convert them back to dictionary via to_dict, e.g","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> Configurations.to_dict(option)\nOrderedDict{String, Any} with 2 entries:\n  \"opt\"   => OrderedDict{String, Any}(\"name\"=>\"Roger\", \"int\"=>2)\n  \"float\" => 0.33","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for serialization, you can use the builtin TOML support","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> to_toml(option)\n\"float = 0.33\\n\\n[opt]\\nname = \\\"Roger\\\"\\nint = 2\\n\"","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Or serialize it to other format from OrderedDict.","category":"page"},{"location":"quick-start/#Create-pretty-printing-for-your-option-type","page":"Quick Start","title":"Create pretty printing for your option type","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can overload the Base.show method to create your own pretty printing. However, if you are fine with the printing style provided by GarishPrint, you can simply define the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"# using GarishPrint\nBase.show(io::IO, ::MIME\"text/plain\", x::MyOption) = GarishPrint.pprint_struct(io, x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"This will enable pretty printing provided by GarishPrint when a rich text environment is available, and it will fallback to the default julia printing if \"text/plain\" MIME type is not available.","category":"page"},{"location":"quick-start/#Read-from-Keyword-Arguments","page":"Quick Start","title":"Read from Keyword Arguments","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Option types can be used to organize large number of keyword arguments, and one can also construct an option type from keyword arguments via from_kwargs","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations.from_kwargs","category":"page"},{"location":"quick-start/#Configurations.from_kwargs","page":"Quick Start","title":"Configurations.from_kwargs","text":"from_kwargs(convention!, ::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using convention!. See also from_dict.\n\nConvention\n\nfrom_underscore_kwargs!: use _ to disambiguate subfields of the same name, this is the default behaviour.\nfrom_field_kwargs!: do not disambiguate subfields, errors if there are disambiguity\n\n\n\n\n\nfrom_kwargs(::Type{T}; kw...) where T\n\nConvert keyword arguments to given option type T using the underscore convention.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"A real world example is the Pluto configuration.","category":"page"},{"location":"quick-start/#Read-from-TOML-files","page":"Quick Start","title":"Read from TOML files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations supports TOML file by default via the TOML standard library, you can directly read a TOML file to your option types via from_toml.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"from_toml","category":"page"},{"location":"quick-start/#Configurations.from_toml","page":"Quick Start","title":"Configurations.from_toml","text":"from_toml(::Type{T}, filename::String; kw...) where T\n\nConvert a given TOML file filename to an option type T. Valid fields can be override by keyword arguments. See also from_dict.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/#Read-from-YAML-files","page":"Quick Start","title":"Read from YAML files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You can use the JuliaData/YAML package to parse a YAML file to a Dict{String, Any},","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using YAML, Configurations\n\njulia> @option struct MyOption\n           a::Int\n           b::Float64\n       end\n\njulia> data = YAML.load_file(\"test.yml\"; dicttype=Dict{String, Any})\nDict{String, Any} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> from_dict(MyOption, data)\nMyOption(1, 2.0)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"but remember to tell the YAML parser that you would like the keys to be String since from_dict expects the dictionary to be AbstractDict{String}, this can be done via dicttype keyword as above example.","category":"page"},{"location":"quick-start/#Read-JSON-files","page":"Quick Start","title":"Read JSON files","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can read JSON files as a dictionary via JuliaIO/JSON.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON\n\njulia> d = JSON.parse(\"{\\\"a\\\":1,\\\"b\\\":2.1}\")\nDict{String, Any} with 2 entries:\n  \"b\" => 2.1\n  \"a\" => 1\n\njulia> from_dict(MyOption, d)\nMyOption(1, 2.1)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"or for JSON3 you can use the following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON3, Configurations\n\njulia> @option struct OptionA\n        x::String = \"hi\"\n        y::Vector{String} = String[]\n           end\n\njulia> d = JSON3.read(\"\"\"\n           {\"y\": [\"a\"]}\n           \"\"\", Dict{String, Any})\nDict{String, Any} with 1 entry:\n  \"y\" => Any[\"a\"]\n\njulia> from_dict(OptionA, d)\nOptionA(\"hi\", [\"a\"])","category":"page"},{"location":"quick-start/#Read-other-formats","page":"Quick Start","title":"Read other formats","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For other formats, as long as you can convert them to a subtype of AbstractDict{String}, you can always convert it to the option type you just defined via from_dict, however for the sake of simplicity Configurations will not ship such functionality with it.","category":"page"},{"location":"quick-start/#Write-to-TOML","page":"Quick Start","title":"Write to TOML","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To write the option struct to a TOML file, simply use the to_toml function","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> to_toml(option; include_defaults=false) # write to a String\n\njulia> to_toml(\"test.toml\", option; include_defaults=false) # write to a file","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"You may also be interested in the docstring of to_toml","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"to_toml","category":"page"},{"location":"quick-start/#Configurations.to_toml","page":"Quick Start","title":"Configurations.to_toml","text":"to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to IO. See to_dict for other valid keyword options. See also TOML.print in the stdlib for the explaination of sorted, by and f.\n\nExclude nothing\n\nIn TOML specification, there is no null type. One should exclude the field if it is not specified (of value nothing in Julia). In to_toml the option exclude_nothing is always true.\n\nIn most cases, nothing is used with another type to denote optional or not specified field, thus one should always put a default value nothing to the option struct, e.g\n\nOne should define\n\n@option struct OptionX\n    a::Union{Nothing, Int} = nothing\n    b::Maybe{Int} = nothing\nend\n\nHere Maybe{T} is a convenient alias of Union{Nothing, T}.\n\n\n\n\n\nto_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)\n\nConvert an instance option of option type to TOML and write it to filename. See also TOML.print.\n\n\n\n\n\nto_toml(x; sorted=false, by=identity, kw...)\n\nConvert an instance x of option type to TOML and write it to String. See also TOML.print. \n\nto_toml does not export fields that are of the same values as the defaults. This can be  overridden by changing include_defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"quick-start/#Write-to-YAML","page":"Quick Start","title":"Write to YAML","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"To write the option struct to other formats, you need to convert it to a dictionary type first via to_dict","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"to_dict","category":"page"},{"location":"quick-start/#Configurations.to_dict","page":"Quick Start","title":"Configurations.to_dict","text":"to_dict(x; include_defaults=true, exclude_nothing=false) -> OrderedDict\n\nConvert an object x to an OrderedDict.\n\nKwargs\n\ninclude_defaults: include the default value, default is true.\nexclude_nothing: exclude fields that have value nothing,   this supersedes include_defaults when they are both true.\n\nFormat Compatibilty\n\nWhen mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as TOMLStyle, YAMLStyle, JSONStyle.\n\ntips: Tips\nto_dict does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use include_defaults, however,  this can be overridden by changing include_defaults to true.\n\n\n\n\n\nto_dict(x, option::ToDictOption) -> OrderedDict\n\nConvert an object x to an OrderedDict with ToDictOption specified.\n\nExample\n\nto_dict(x, TOMLStyle) # TOML compatible\nto_dict(x, YAMLStyle) # YAML compatible\nto_dict(x, JSONStyle) # JSON compatible\n\n\n\n\n\nto_dict(::Type{T}, x, option::ConvertOption) where T\n\nConvert x when x is inside an option type T. option is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of to_dict(x; kw...).\n\nto_dict(::Type{T}, x) where T\n\nOne can also use the 2-arg version when x is not or does not contain an option type for convenience.\n\nExample\n\nThe following is a builtin overload to handle list of options.\n\nfunction Configurations.to_dict(::Type{T}, x::Vector, option::ConvertOption) where T\n    if is_option(eltype(x))\n        return map(p->to_dict(T, p, include_defaults), x)\n    else\n        return x\n    end\nend\n\nThe following overloads the 2-arg to_dict to convert all VersionNumber to a String for all kinds of option types.\n\nConfigurations.to_dict(::Type, x::VersionNumber) = string(x)\n\n\n\n\n\n","category":"function"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Then you can use YAML package to write the dict to a YAML file","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using YAML, Configurations\n\njulia> d = to_dict(your_option, YAMLStyle)\n\njulia> YAML.write_file(\"myfile.yaml\", d)","category":"page"},{"location":"quick-start/#Write-to-JSON","page":"Quick Start","title":"Write to JSON","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"or for JSON, we recommend using JSON or JSON3 to write the file as following","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for JSON","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON, Configurations\n\njulia> d = to_dict(your_option, JSONStyle)\n\njulia> open(\"file.json\", \"w\") do f\n           JSON.print(f, d)\n       end","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"for JSON3 you can use the following code snippet","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"julia> using JSON3, Configurations\n\njulia> @option struct OptionA\n        x::String = \"hi\"\n        y::Vector{String} = String[]\n    end\n\njulia> d = to_dict(OptionA(y=[\"a\"]))\n\njulia> JSON3.write(d)\n\"{\\\"x\\\":\\\"hi\\\",\\\"y\\\":[\\\"a\\\"]}\"\n\njulia> JSON3.write(\"file.json\", d) # write to a file\n\"file.json\"","category":"page"},{"location":"quick-start/#Write-to-other-formats","page":"Quick Start","title":"Write to other formats","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For other formats, you can convert your option struct to an OrderedDict{String, Any} via to_dict then serialize the dictionary to your desired format.","category":"page"},{"location":"quick-start/#Work-with-StructTypes-and-JSON3","page":"Quick Start","title":"Work with StructTypes and JSON3","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"One can work with StructType with Configurations to make JSON.read(json_string, MyOptionType) work automatically by copying the following code and replace MyOptionType with your own option struct types.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"using StructTypes\nusing Configurations\nStructTypes.StructType(::Type{<:MyOptionType}) = StructTypes.CustomStruct()\nStructTypes.lower(x::MyOptionType) = to_dict(x, JSONStyle)\nStructTypes.lowertype(::Type{<:MyOptionType}) = OrderedDict{String, Any}\nStructTypes.construct(::Type{T}, x) where {T <: MyOptionType} = from_dict(T, x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"then JSON.read(\"// a json string or IO\", MyOptionType) will just work.","category":"page"},{"location":"quick-start/#Type-Conversion","page":"Quick Start","title":"Type Conversion","text":"","category":"section"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Since markup languages usually do not support arbitrary Julia types, thus, one may find the from_dict complain that cannot convert an object of type XXX to an object of type YYY. Usually this is because you haven't overload Base.convert from XXX to YYY for the custom struct type, usually this can be resolved via the following overload","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Base.convert(::Type{MyType}, x::String) = MyType(x)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"where we assume you have written a constructor from String here.","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"However, in some cases, you may want to do the conversion only for one OptionType without causing type piracy, for example, one may want to convert all the String to Symbol for MyOption, this can be done by overloading Configurations.convert_to_option","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"Configurations.convert_to_option(::Type{MyOption}, ::Type{Symbol}, s) = Symbol(s)","category":"page"},{"location":"quick-start/","page":"Quick Start","title":"Quick Start","text":"For more detailed type conversion mechanism, please read the Type Conversion section.","category":"page"},{"location":"convert/#type-conversion","page":"Type Conversion","title":"Type Conversion and Custom Parsing","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"If you find from_dict or from_toml doesn't not support a Julia type, such as Symbol, this is usually because the corresponding parser or format doesn't support this Julia type natively, in this case you will need to define your own type conversion for this option type by overloading Configurations.convert_to_option","category":"page"},{"location":"convert/#How-does-it-work?","page":"Type Conversion","title":"How does it work?","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"The type conversion for option types work as following:","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"if we find the target type does not match the value type, we will call Configurations.convert_to_option\nif Configurations.convert_to_option is not overloaded, it will return Configurations.ConvertNotFound otherwise, it will return the converted value.\nif we see Configurations.ConvertNotFound we will call Base.convert, if this doesn't work, a standard conversion failure error will be thrown by Base.convert.","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"Thus, if Base.convert is already overloaded, this will just work, or if the conversion rule is contextual based on the option type, one can also overload Configurations.convert_to_option, this also avoids potential type piracy.","category":"page"},{"location":"convert/#Example:-Contextual-Conversion","page":"Type Conversion","title":"Example: Contextual Conversion","text":"","category":"section"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"using Configurations\n\n@option struct MyOption\n    a::Int\n    b::Symbol\nend","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"directly calling from_dict will have the following error","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"julia> @option struct MyOption\n           a::Int\n           b::Symbol\n       end\n\njulia> d = Dict{String, Any}(\n           \"a\" => 1,\n           \"b\" => \"ccc\"\n       )\nDict{String, Any} with 2 entries:\n  \"b\" => \"ccc\"\n  \"a\" => 1\n\njulia> from_dict(MyOption, d)\nERROR: MethodError: Cannot `convert` an object of type String to an object of type Symbol\nClosest candidates are:\n  convert(::Type{T}, ::T) where T at essentials.jl:205\n  Symbol(::String) at boot.jl:478\n  Symbol(::AbstractString) at strings/basic.jl:228\n  ...","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"now if we define the following type conversion","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"Configurations.convert_to_option(::Type{MyOption}, ::Type{Symbol}, s) = Symbol(s)","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"it will just work","category":"page"},{"location":"convert/","page":"Type Conversion","title":"Type Conversion","text":"julia> from_dict(MyOption, d)\nMyOption(1, :ccc)","category":"page"}]
}
