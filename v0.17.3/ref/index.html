<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>References · Configurations.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Roger-luo.github.io/Configurations.jl/ref/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Configurations.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quick-start/">Quick Start</a></li><li><a class="tocitem" href="../convert/">Type Conversion</a></li><li><a class="tocitem" href="../type_alias/">Option Type Alias</a></li><li><a class="tocitem" href="../meta/">Meta Programming</a></li><li class="is-active"><a class="tocitem" href>References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Roger-luo/Configurations.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Configurations.JSONStyle" href="#Configurations.JSONStyle"><code>Configurations.JSONStyle</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">JSONStyle::ToDictOption</code></pre><p>Predefined option for JSON compatible <a href="../quick-start/#Configurations.to_dict"><code>to_dict</code></a> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.Maybe" href="#Configurations.Maybe"><code>Configurations.Maybe</code></a> — <span class="docstring-category">Type</span></header><section><div><p>maybe of type <code>T</code> or nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.TOMLStyle" href="#Configurations.TOMLStyle"><code>Configurations.TOMLStyle</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TOMLStyle::ToDictOption</code></pre><p>Predefined option for TOML compatible <a href="../quick-start/#Configurations.to_dict"><code>to_dict</code></a> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.YAMLStyle" href="#Configurations.YAMLStyle"><code>Configurations.YAMLStyle</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">YAMLStyle::ToDictOption</code></pre><p>Predefined option for YAML compatible <a href="../quick-start/#Configurations.to_dict"><code>to_dict</code></a> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.ConvertNotFound" href="#Configurations.ConvertNotFound"><code>Configurations.ConvertNotFound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvertNotFound</code></pre><p>Conversion is not defined via <a href="#Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T"><code>convert_to_option</code></a>. One should let the conversion fallback to <code>Base.convert</code> when see this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.DuplicatedFieldError" href="#Configurations.DuplicatedFieldError"><code>Configurations.DuplicatedFieldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DuplicatedFieldError(name, type)</code></pre><p>A field with <code>name</code> of given option <code>type</code> is duplicated in the subfields option type. Thus one cannot use the field keyword convention when seeing this error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.FieldTypeConversionError" href="#Configurations.FieldTypeConversionError"><code>Configurations.FieldTypeConversionError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldTypeConversionError(type, fieldname, fieldtype, optiontype)</code></pre><p>A conversion from <code>type</code> to <code>fieldtype</code> belonging to <code>fieldname</code> in an <code>optiontype</code> failed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.OptionField" href="#Configurations.OptionField"><code>Configurations.OptionField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OptionField{name}
OptionField(name::Symbol)</code></pre><p>Trait type that denotes a field of an option type. Mainly used for dispatch purpose. <code>name</code> should be a <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.PartialDefault" href="#Configurations.PartialDefault"><code>Configurations.PartialDefault</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialDefault{F}</code></pre><p>Type for non-constant default value, it depends on the value of another field that has default value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.alias_map-Tuple{Vector{Any}}" href="#Configurations.alias_map-Tuple{Vector{Any}}"><code>Configurations.alias_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alias_map(types::Vector{Any})</code></pre><p>Create a <code>Dict</code> mapping type alias to a type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.compare_options-Tuple{Any, Any, Vararg{Any}}" href="#Configurations.compare_options-Tuple{Any, Any, Vararg{Any}}"><code>Configurations.compare_options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare_options(a, b, xs...)::Bool</code></pre><p>Compare option types check if they are the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T" href="#Configurations.convert_to_option-Union{Tuple{T}, Tuple{Type, Type{T}, Any}} where T"><code>Configurations.convert_to_option</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert_to_option(::Type{OptionType}, ::Type{ValueType}, x) where {OptionType, ValueType}</code></pre><p>Convert <code>x</code> to type <code>ValueType</code> for option type <code>OptionType</code>. This is similar to <code>Base.convert</code>, but will not error if the conversion is not overloaded, and will return a <a href="#Configurations.ConvertNotFound"><code>ConvertNotFound</code></a> object, but one can use this to avoid type piracy and define contextual conversion based on option types.</p><div class="admonition is-compat"><header class="admonition-header">Configurations 0.17</header><div class="admonition-body"><p>This interface is deprecated in favor of <a href="../convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField, Type{T}, Any}} where {OptionType, T}"><code>from_dict</code></a> from 0.17.</p></div></div><p><strong>Example</strong></p><p>One may have different string syntax for a <code>Symbol</code>, e.g</p><pre><code class="language-julia hljs">@option struct StringIsSymbol
    name::Symbol
end

@option struct SymbolNeedsColon
    name::Symbol
end

Configurations.convert_to_option(::Type{StringIsSymbol}, ::Type{Symbol}, x::String) = Symbol(x)

function Configurations.convert_to_option(::Type{SymbolNeedsColon}, ::Type{Symbol}, x::String)
    if startswith(x, &#39;:&#39;)
        Symbol(x[2:end])
    else
        error(&quot;expect a Symbol, got String&quot;)
    end
end</code></pre><p>then if we run it, we will have different behaviour by context.</p><pre><code class="language-julia hljs">julia&gt; from_dict(StringIsSymbol, d)
StringIsSymbol(:ccc)

julia&gt; from_dict(SymbolNeedsColon, d)
ERROR: expect a Symbol, got String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.create-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.create-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create(::Type{T}; kwargs...) where T</code></pre><p>Create an instance of option type <code>T</code> from <code>kwargs</code>. Similar to the default keyword argument constructor, but one can use this to create custom keyword argument constructor with extra custom keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.field_default-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T" href="#Configurations.field_default-Union{Tuple{T}, Tuple{Type{T}, Symbol}} where T"><code>Configurations.field_default</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_default(::Type{T}, name::Symbol)</code></pre><p>Return the default value of field <code>name</code> of an option type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.field_defaults-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.field_defaults-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.field_defaults</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_defaults(::Type)</code></pre><p>Return default values of given option types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.field_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.field_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.field_keywords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">field_keywords(::Type{T}) where T</code></pre><p>Return all the option type field names given <code>T</code>, error if there are duplicated sub-fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_dict-Union{Tuple{OptionType}, Tuple{Type{OptionType}, AbstractDict{String}}} where OptionType" href="#Configurations.from_dict-Union{Tuple{OptionType}, Tuple{Type{OptionType}, AbstractDict{String}}} where OptionType"><code>Configurations.from_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_dict(::Type{T}, d::AbstractDict{String}; kw...) where T</code></pre><p>Convert dictionary <code>d</code> to an option type <code>T</code>, the value of valid fields of <code>T</code> in this dictionary <code>d</code> can be override by keyword arguments.</p><div class="admonition is-compat"><header class="admonition-header">Configurations 0.17</header><div class="admonition-body"><p><code>convert_to_option</code> interface is deprecated for conversion, please overload the 3-arg or 4-arg <code>from_dict</code> instead. See also <a href="../convert/#type-conversion">Type Conversion</a> section.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @option struct OptionA
           name::String = &quot;Sam&quot;
           age::Int = 25
       end

julia&gt; d = Dict{String, Any}(
           &quot;name&quot; =&gt; &quot;Roger&quot;,
           &quot;age&quot; =&gt; 10,
       );

julia&gt; from_dict(OptionA, d; age=25)
OptionA(;
    name = &quot;Roger&quot;,
    age = 25,
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_dict-Union{Tuple{T}, Tuple{f_name}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField{f_name}, Type{T}, Any}} where {OptionType, f_name, T}" href="#Configurations.from_dict-Union{Tuple{T}, Tuple{f_name}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField{f_name}, Type{T}, Any}} where {OptionType, f_name, T}"><code>Configurations.from_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_dict(::Type{OptionType}, ::OptionField{f_name}, ::Type{T}, x) where {OptionType, f_name, T}</code></pre><p>For option type <code>OptionType</code>, convert the object <code>x</code> to the field type <code>T</code> and assign it to the field <code>f_name</code>. Raise <code>FieldTypeConversionError</code>s errors if <code>Base.convert</code> raises exception</p><pre><code class="nohighlight hljs">ERROR: MethodError: Cannot `convert` an object of type ...</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_dict_generated-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Symbol}} where OptionType" href="#Configurations.from_dict_generated-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Symbol}} where OptionType"><code>Configurations.from_dict_generated</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_dict_generated(::Type{OptionType}, value::Symbol) where {OptionType}</code></pre><p>Generate a specialized Julia expression to convert an <code>AbstractDict{String}</code> to our <code>OptionType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_dict_specialize-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Any}} where OptionType" href="#Configurations.from_dict_specialize-Union{Tuple{OptionType}, Tuple{Type{OptionType}, Any}} where OptionType"><code>Configurations.from_dict_specialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_dict_specialize(::Type{OptionType}, x) where {OptionType}</code></pre><p>A specialized <a href="../convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField, Type{T}, Any}} where {OptionType, T}"><code>from_dict</code></a> method for option type <code>OptionType</code>. This is usually generated by <a href="../#Configurations.@option"><code>@option</code></a>, but one may also specialized this manually to acheive maximal performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_field_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.from_field_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.from_field_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_field_kwargs(::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using the field keyword convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_kwargs!-Union{Tuple{T}, Tuple{AbstractDict{String}, Type{T}}, Tuple{AbstractDict{String}, Type{T}, Union{Nothing, Symbol}}} where T" href="#Configurations.from_kwargs!-Union{Tuple{T}, Tuple{AbstractDict{String}, Type{T}}, Tuple{AbstractDict{String}, Type{T}, Union{Nothing, Symbol}}} where T"><code>Configurations.from_kwargs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_kwargs!(d::AbstractDict{String}, ::Type{T}, prefix::Maybe{Symbol} = nothing; kw...) where T</code></pre><p>Internal method for inserting keyword arguments to given dictionary object <code>d</code>. It will overwrite existing keys in <code>d</code> if it is specified by keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.from_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.from_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_kwargs(::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using the underscore convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_kwargs-Union{Tuple{T}, Tuple{Any, Type{T}}} where T" href="#Configurations.from_kwargs-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><code>Configurations.from_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_kwargs(convention!, ::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using <code>convention!</code>. See also <a href="../convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField, Type{T}, Any}} where {OptionType, T}"><code>from_dict</code></a>.</p><p><strong>Convention</strong></p><ul><li><code>from_underscore_kwargs!</code>: use <code>_</code> to disambiguate subfields of the same name, this is the default behaviour.</li><li><code>from_field_kwargs!</code>: do not disambiguate subfields, errors if there are disambiguity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_toml-Union{Tuple{T}, Tuple{Type{T}, String}} where T" href="#Configurations.from_toml-Union{Tuple{T}, Tuple{Type{T}, String}} where T"><code>Configurations.from_toml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_toml(::Type{T}, filename::String; kw...) where T</code></pre><p>Convert a given TOML file <code>filename</code> to an option type <code>T</code>. Valid fields can be override by keyword arguments. See also <a href="../convert/#Configurations.from_dict-Union{Tuple{T}, Tuple{OptionType}, Tuple{Type{OptionType}, OptionField, Type{T}, Any}} where {OptionType, T}"><code>from_dict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_toml_if_exists-Union{Tuple{T}, Tuple{Type{T}, String}} where T" href="#Configurations.from_toml_if_exists-Union{Tuple{T}, Tuple{Type{T}, String}} where T"><code>Configurations.from_toml_if_exists</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_toml_if_exists(::Type{T}, filename::String; kw...) where T</code></pre><p>Similar to <a href="../quick-start/#Configurations.from_toml"><code>from_toml</code></a> but will create the option instance via <code>from_kwargs(T;kw...)</code> instead of error if the file does not exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.from_underscore_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.from_underscore_kwargs-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.from_underscore_kwargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">from_underscore_kwargs(::Type{T}; kw...) where T</code></pre><p>Convert keyword arguments to given option type <code>T</code> using the underscore convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.has_same_reflect_field-Tuple{Vector{Any}}" href="#Configurations.has_same_reflect_field-Tuple{Vector{Any}}"><code>Configurations.has_same_reflect_field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_same_reflect_field(types::Vector{Any})</code></pre><p>Check if all types has the same reflect field name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.ignore_extra-Union{Tuple{Type{OptionType}}, Tuple{OptionType}} where OptionType" href="#Configurations.ignore_extra-Union{Tuple{Type{OptionType}}, Tuple{OptionType}} where OptionType"><code>Configurations.ignore_extra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ignore_extra(option_type) -&gt; Bool</code></pre><p>Return <code>true</code> if the option type ignores extra fields when read from a dict-like object.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Normally, we require the dict-like object to have exactly the same number of fields with the option type. However, it could be useful to have ignore extra fields when wrapping network work services to ignore some irrelavent optional fields.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Unlike <a href="https://pydantic-docs.helpmanual.io/usage/model_config/">pydantic</a>, we do not allow dynamically adding fields to a given type. One should manually define fields you would like to include in a struct type and let it to have type <code>Dict{String, Any}</code>.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; Configurations.ignore_extra(::Type{MyOption}) = true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.is_option-Tuple{Any}" href="#Configurations.is_option-Tuple{Any}"><code>Configurations.is_option</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_option(x)</code></pre><p>Check if <code>x</code> is an option type or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.is_option_maybe-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.is_option_maybe-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.is_option_maybe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_option_maybe(::Type{T}) where T</code></pre><p><code>T</code> is an option struct or if <code>T</code> is an union, one of the types is an option struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_dict-Tuple{Any, Configurations.ToDictOption}" href="#Configurations.to_dict-Tuple{Any, Configurations.ToDictOption}"><code>Configurations.to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_dict(x, option::ToDictOption) -&gt; OrderedDict</code></pre><p>Convert an object <code>x</code> to an <code>OrderedDict</code> with <code>ToDictOption</code> specified.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">to_dict(x, TOMLStyle) # TOML compatible
to_dict(x, YAMLStyle) # YAML compatible
to_dict(x, JSONStyle) # JSON compatible</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_dict-Tuple{Any}" href="#Configurations.to_dict-Tuple{Any}"><code>Configurations.to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_dict(x; include_defaults=true, exclude_nothing=false) -&gt; OrderedDict</code></pre><p>Convert an object <code>x</code> to an <code>OrderedDict</code>.</p><p><strong>Kwargs</strong></p><ul><li><code>include_defaults</code>: include the default value, default is <code>true</code>.</li><li><code>exclude_nothing</code>: exclude fields that have value <code>nothing</code>,   this supersedes <code>include_defaults</code> when they are both <code>true</code>.</li></ul><p><strong>Format Compatibilty</strong></p><p>When mapping an option struct from Julia to TOML/YAML/JSON/etc. format, there are some subtle semantic compatibilty one need to deal with, we provide some convenient predefined conversion option constants as <a href="#Configurations.TOMLStyle"><code>TOMLStyle</code></a>, <a href="#Configurations.YAMLStyle"><code>YAMLStyle</code></a>, <a href="#Configurations.JSONStyle"><code>JSONStyle</code></a>.</p><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p><code>to_dict</code> does not export fields that are of the same values as the defaults.  In most cases, this should be the default behaviour, and users should not use <code>include_defaults</code>, however,  this can be overridden by changing <code>include_defaults</code> to <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_dict-Union{Tuple{T}, Tuple{Type{T}, Any, Configurations.ToDictOption}} where T" href="#Configurations.to_dict-Union{Tuple{T}, Tuple{Type{T}, Any, Configurations.ToDictOption}} where T"><code>Configurations.to_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_dict(::Type{T}, x, option::ToDictOption) where T</code></pre><p>Convert <code>x</code> when <code>x</code> is inside an option type <code>T</code>. <code>option</code> is a set of options to determine the conversion behaviour. this can be overloaded to change the behaviour of <code>to_dict(x; kw...)</code>.</p><pre><code class="nohighlight hljs">to_dict(::Type{T}, x) where T</code></pre><p>One can also use the 2-arg version when <code>x</code> is not or does not contain an option type for convenience.</p><p><strong>Example</strong></p><p>The following is a builtin overload to handle list of options.</p><pre><code class="language-julia hljs">function Configurations.to_dict(::Type{T}, x::Vector, option::ToDictOption) where T
    if is_option(eltype(x))
        return map(p-&gt;to_dict(T, p, include_defaults), x)
    else
        return x
    end
end</code></pre><p>The following overloads the 2-arg <code>to_dict</code> to convert all <code>VersionNumber</code> to a <code>String</code> for all kinds of option types.</p><pre><code class="language-julia hljs">Configurations.to_dict(::Type, x::VersionNumber) = string(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_toml-Tuple{Any, IO, Any}" href="#Configurations.to_toml-Tuple{Any, IO, Any}"><code>Configurations.to_toml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_toml([f::Function], io::IO, option; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>option</code> of option type to TOML and write it to <code>IO</code>. See <a href="../quick-start/#Configurations.to_dict"><code>to_dict</code></a> for other valid keyword options. See also <code>TOML.print</code> in the stdlib for the explaination of <code>sorted</code>, <code>by</code> and <code>f</code>.</p><p><strong>Exclude <code>nothing</code></strong></p><p>In TOML specification, there is <a href="https://github.com/toml-lang/toml/issues/802">no null type</a>. One should exclude the field if it is not specified (of value <code>nothing</code> in Julia). In <code>to_toml</code> the option <code>exclude_nothing</code> is always <code>true</code>.</p><p>In most cases, <code>nothing</code> is used with another type to denote optional or not specified field, thus one should always put a default value <code>nothing</code> to the option struct, e.g</p><p>One should define</p><pre><code class="language-julia hljs">@option struct OptionX
    a::Union{Nothing, Int} = nothing
    b::Maybe{Int} = nothing
end</code></pre><p>Here <code>Maybe{T}</code> is a convenient alias of <code>Union{Nothing, T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_toml-Tuple{Any, String, Any}" href="#Configurations.to_toml-Tuple{Any, String, Any}"><code>Configurations.to_toml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_toml([f::Function], filename::String, option; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>option</code> of option type to TOML and write it to <code>filename</code>. See also <code>TOML.print</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.to_toml-Tuple{Any}" href="#Configurations.to_toml-Tuple{Any}"><code>Configurations.to_toml</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_toml(x; sorted=false, by=identity, kw...)</code></pre><p>Convert an instance <code>x</code> of option type to TOML and write it to <code>String</code>. See also <code>TOML.print</code>. </p><p><code>to_toml</code> does not export fields that are of the same values as the defaults. This can be  overridden by changing <code>include_defaults</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.type_alias-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.type_alias-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.type_alias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">type_alias(::Type{OptionType}) -&gt; String</code></pre><p>Return the alias name of given <code>OptionType</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.underscore_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Configurations.underscore_keywords-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Configurations.underscore_keywords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">underscore_keywords(::Type{T}) where T</code></pre><p>Return keywords given <code>T</code> using the underscore convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.@option-Tuple{Any}" href="#Configurations.@option-Tuple{Any}"><code>Configurations.@option</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@option [alias::String] &lt;struct def&gt;</code></pre><p>Define an option struct type. This will auto-generate methods that parse a given <code>Dict{String}</code> object (the keys must be of type <code>String</code>) into an instance of the struct type you defined. One can use <code>alias</code> string to distinguish multiple possible option type for the same field.</p><p><strong>Special Types</strong></p><ul><li><code>Maybe{T}</code>: this type is equivalent to <code>Union{Nothing, T}</code> and   is treated specially in <code>@option</code>, it will always have a default   value of <code>nothing</code> if not specified.</li><li><a href="../quick-start/#Configurations.Reflect"><code>Reflect</code></a>: this type is treated specially to allow one to use a field   to store the corresponding type information.</li></ul><div class="admonition is-compat"><header class="admonition-header">Configurations 0.16</header><div class="admonition-body"><p>from v0.16.0 Configurations stops overloading the <code>Base.show</code> method for you, if you need pretty printing of your option types, consider overloading the <code>Base.show(io::IO, mime::MIME, x)</code> method to <code>pprint_struct(io, mime, x)</code> provided by <a href="https://github.com/Roger-luo/GarishPrint.jl">GarishPrint</a></p></div></div><div class="admonition is-compat"><header class="admonition-header">Configurations 0.12</header><div class="admonition-body"><p>from v0.12.0 the field alias feature is removed due to the syntax conflict with field docstring. Please refer to <a href="https://github.com/Roger-luo/Configurations.jl/issues/17">#17</a>.</p></div></div><p><strong>Example</strong></p><p>One can define option type via <code>@option</code> macro with or without an alias.</p><pre><code class="language-julia-repl hljs">julia&gt; &quot;Option A&quot;
       @option &quot;option_a&quot; struct OptionA
           name::String
           int::Int = 1
       end

julia&gt; &quot;Option B&quot;
       @option &quot;option_b&quot; struct OptionB
           opt::OptionA = OptionA(;name = &quot;Sam&quot;)
           float::Float64 = 0.3
       end
julia&gt; option = from_dict(OptionB, d)
OptionB(;
    opt = OptionA(;
        name = &quot;Roger&quot;,
        int = 2,
    ),
    float = 0.33,
)</code></pre><p>when there are multiple possible option type for one field, one can use the alias to distinguish them</p><pre><code class="language-julia-repl hljs">julia&gt; @option struct OptionD
           opt::Union{OptionA, OptionB}
       end

julia&gt; d1 = Dict{String, Any}(
               &quot;opt&quot; =&gt; Dict{String, Any}(
                   &quot;option_b&quot; =&gt; d
               )
           );

julia&gt; from_dict(OptionD, d1)
OptionD(;
    opt = OptionB(;
        opt = OptionA(;
            name = &quot;Roger&quot;,
            int = 2,
        ),
        float = 0.33,
    ),
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Configurations.@type_alias-Tuple{Any, String}" href="#Configurations.@type_alias-Tuple{Any, String}"><code>Configurations.@type_alias</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@type_alias &lt;type&gt; &lt;name::String&gt;</code></pre><p>Define a type alias for option type <code>type</code>. The corresponding <code>type</code> must be a concrete type in order to map this Julia type to a human readable markup language (e.g TOML, YAML, etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Roger-luo/Configurations.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meta/">« Meta Programming</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 15 February 2022 14:28">Tuesday 15 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
